*csupport.txt*                  C/C++ Support                    2011-06-26

C/C++ Support                                           *c-support* *csupport*
                              插件版本 5.14
                    针对 Vim version 7.0 及其以上版本
                  作者: Fritz Mehner  <mehner@fh-swf.de>
              译者: Tiger Lee     <i.m.tiger.lee[AT]gmail.com>

Vim/gVim 的 C/C++-IDE。开发它是为了极为迅速地以一致的风格来编写代码。这是通过
插入整句，惯用法，代码片断，模板和注释来完成的。并可使用一键来完成语法检查，
编译，运行程序，运行代码检查工具或重新格式化代码。

 1.    在 GUI 下使用                            |csupport-usage-gvim|
 1.1    'Comments' 菜单                         |csupport-comm|
 1.1.1   追加已对齐注释                         |csupport-comm-aligned|
 1.1.2   调整行尾注释                           |csupport-comm-realign|
 1.1.3   代码转注释                             |csupport-code-to-comm|
 1.1.4   注释转代码                             |csupport-comm-to-code|
 1.1.5   框注释，文件头，...                    |csupport-comm-frame|
 1.1.6   文件区块注释...                        |csupport-comm-sections|
 1.1.7   关键字注释，特殊注释                   |csupport-comm-keyword|
 1.1.8   标记（插件）                           |csupport-comm-tags|
 1.1.9   日期和日期+时间                        |csupport-comm-date|
 1.1.10  C 注释转 C++ 注释，反之亦然            |csupport-comm-c-cpp|
 1.2    'Statements' 菜单                       |csupport-stat|
 1.2.1   正常模式，插入模式                     |csupport-stat-normal-mode|
 1.2.2   可视模式                               |csupport-stat-visual-mode|
 1.3    'Preprocessor' 菜单                     |csupport-prep|
 1.3.1   正常模式，插入模式                     |csupport-prep-normal-mode|
 1.3.2   可视模式                               |csupport-prep-visual-mode|
 1.3.3   用 #if 0 .. #endif 封闭代码            |csupport-prep-if0|
 1.3.4   外部命令                               |csupport-prep-ex|
 1.4    'Idioms' 菜单                           |csupport-idioms|
 1.4.1   'function' 项                          |csupport-idioms-function|
 1.4.2   for 循环控制                           |csupport-idioms-for-loop|
 1.4.3   'open input file' 项                   |csupport-idioms-input|
 1.4.4   'open output file' 项                  |csupport-idioms-output|
 1.5    'Snippets' 菜单                         |csupport-snippets|
 1.5.1   代码片断                               |csupport-snippets|
 1.5.2   选择原型                               |csupport-proto|
 1.5.3   代码模板                               |csupport-templates-menu|
 1.6    'C++' 菜单                              |csupport-c++|
 1.6.1   正常模式，插入模式                     |csupport-c++-normal-mode|
 1.6.2   可视模式                               |csupport-c++-visual-mode|
 1.6.3   方法实现                               |csupport-c++-method-impl|
 1.6.4  外部命令                                |csupport-c++-ex|
 1.7    'Run' 菜单                              |csupport-run|
 1.7.1   最小 make 功能                         |csupport-run-buffer|
 1.7.2   命令行参数                             |csupport-run-cmdline-args|
 1.7.3   运行 make                              |csupport-run-make|
 1.7.4   运行可执行程序                         |csupport-run-make-run|
 1.7.5   运行 make clean                        |csupport-run-make-clean|
 1.7.6   make 命令行参数                        |csupport-run-make-args|
 1.7.7   Splint                                 |csupport-run-splint|
 1.7.8   CodeCheck                              |csupport-run-codecheck|
 1.7.9   缩进                                   |csupport-run-indent|
 1.7.10  硬拷贝                                 |csupport-run-hardcopy|
 1.7.11  重新构建模板                           |csupport-run-templates|
 1.7.12  Xterm 大小                             |csupport-run-xterm|
 1.7.13  输出重定向                             |csupport-run-output|
 1.8    帮助                                    |csupport-help|
 2.    没有 GUI 时的用法                        |csupport-usage-vim|
 3.    快捷键                                   |csupport-hotkeys|
 4.    定制和配置                               |csupport-custom|
 4.1    全局变量                                |csupport-custom-glob-vars|
 4.2     根目录                                 |csupport-custom-root|
 4.3     系统级安装                             |csupport-system-wide|
 5.    模板和 tags                              |csupport-templates|
 5.1    模板文件                                |csupport-templates-files|
 5.2    宏                                      |csupport-templates-macros|
 5.2.1  用户定义格式的日期和时间                |csupport-templates-date|
 5.3    模板                                    |csupport-templates-names|
 5.3.1  模板名                                  |csupport-templates-names|
 5.3.2  模板定义                                |csupport-templates-definition|
 5.3.3  模板展开                                |csupport-templates-expansion|
 5.3.4  宏 <+text+> 及其它                      |csupport-templates-jump|
 5.3.5  Ctrl-j 命令                             |csupport-Ctrl-j|
 5.4    模板集间切换                            |csupport-templates-sets|
 5.5    绑定风格到扩展名                        |csupport-templates-bind|
 6.    C/C++ 字典                               |csupport-dictionary|
 7.    扩展 ctags                               |csupport-ctags|
 7.1   Make 和 qmake                            |csupport-ctags-make|
 7.2   模板                                     |csupport-ctags-templates|
 8.    代码折叠                                 |csupport-folding|
 9     额外映射                                 |csupport-ad-mappings|
 10.   Windows 特性                             |csupport-windows|
 11.   额外提示                                 |csupport-tips|
 12.   问题排除                                 |csupport-troubleshooting|
 13.   发布注解 / 变更日志                      |csupport-release-notes|

       怎样把这个帮助文件加入到 Vim 的帮助中    |add-local-help|


==============================================================================
1.  在 GUI 下使用 （gVim）                               *csupport-usage-gvim*
==============================================================================

如果看不见根菜单 'C/C++'，则可从根菜单 'Tools' 的子项 "Load C Support" 启用它。
菜单项 "Load C Support" 同样也可用于卸载根目录 'C/C++'。

几乎所有的菜单项都会插入代码片断或注释。所有这些都包含在模板文件中，并且可以由
用户修改以达到他们的需求（参见|csupport-templates|）。

------------------------------------------------------------------------------
1.1 'Comments' 菜单                                            *csupport-comm*
------------------------------------------------------------------------------

1.1.1  在连续行中追加已对齐的注释                      *csupport-comm-aligned*

在正常模式，菜单项 "end-of-line comment" 将会在当前行追加一条注释。
在可视模式，这个选项将会在所有已标记的行追加已对齐的注释。
标记前面 4 行。

  print_double_array ( double array[],
                       int    n,
                       int    columns,
                       char*  arrayname
                       )

并且选中 'end-of-line com'，将会产生 '/*  */'。

  print_double_array ( double array[],          /*  */
                       int    n,                /*  */
                       int    columns,          /*  */
                       char*  arrayname         /*  */
                       )

如果有一行或多行超过起始列，注释将会在最长那行之后的第二列开始。光标将会放置
在第一条注释里。

默认的起始列是 49 （ = （2，4 或 8 的倍数）+ 1）。这个值可以在文件 ~/.vimrc 中
设定一个全局变量来改变，如:

  let g:C_LineEndCommColDefault    = 45

起始列也可以由菜单项 'Comments->set end-of-line com. col' 设定。只需将光标放置
于任意列（列数显示在Vim的状态栏）并且选择这个菜单项。这个设定与缓冲区有关。

如果光标位于行尾，你将会被询问一个列数，因为这个位置极有可能不是想要的起始列。
你的选择会被确认。

------------------------------------------------------------------------------

1.1.2  调整行尾注释                                   *csupport-comm-realign*

在一些改动后，行尾注释可能不再整齐了:

  print_double_array ( double       array[],    /*  */
                       long int     n,          /*  */
                       unsigned int columns,    /*  */
                       char*        a_name      /*  */
                       )                        /*  */

使用菜单项 'adjust end-of-line com.' 可以实现重新对齐。 在正常模式下，当前行的
注释（如果有的话）会尽可能的与行尾注释列（如下）对齐。在可视模式下，标记的块会
被对齐:

  print_double_array ( double       array[],    /*  */
                       long int     n,          /*  */
                       unsigned int columns,    /*  */
                       char*        a_name      /*  */
                       )                        /*  */

只有前导空格的注释不会重新对齐，它们通常都是标题:

  max = other.max;                    /* the maximum value */
  len = other.len;                    /* the length        */
  /* ===== the next section ===== */
  pos = (x+y+z)/3.0;                  /* the next position */

在对齐之后:

  max = other.max;                              /* the maximum value */
  len = other.len;                              /* the length        */
  /* ===== the next section ===== */
  pos = (x+y+z)/3.0;                            /* the next position */

------------------------------------------------------------------------------

1.1.3  代码转注释                                      *csupport-code-to-comm*

标记块

xxxxxxxx
xxxxxxxx
xxxxxxxx

将会由菜单项 'code->comment /**/' 变成多行注释（全部或部分标记的行）:

/* xxxxxxxx
 * xxxxxxxx
 * xxxxxxxx
 */

标记块将会由菜单项 'code->comment //' 变成多行注释:

//xxxxxxxx
//xxxxxxxx
//xxxxxxxx

这两个菜单项也作用于单行，但没必要先标记单行。

------------------------------------------------------------------------------

1.1.4  注释转代码                                      *csupport-comm-to-code*

如果标记了一行（或多行）完整的注释（如:所有的行都属于注释），菜单项
"comment->code" 将会取消注释，如果标记了以下行:

   * printf ("\n");
   */

  printf ("\n");

  //  printf ("\n");
  //

  /*
   *  printf ("\n");
   */

取消注释将会变成

   * printf ("\n");
   */

  printf ("\n");

  printf ("\n");



  printf ("\n");

前两行仅仅是 C 注释的一部分，所以保持不变。一条 C 注释的开始可以是 /*，/** 或者
/*!。

这个菜单项也作用于前导为 // 的单行，但没必要先标记单行。

------------------------------------------------------------------------------

1.1.5  框注释，文件头，...                               *csupport-comm-frame*

框注释、文件头注释、函数注释、方法注释和类描述注释都是从对应的文件中做为模板
读取的。（参见 |csupport-templates|）。

一共有两种类型的文件描述模板（菜单项 "file description (impl.)" 和
"file description (header)"，同样参见 |csupport-templates|）:

  comment.file-description         : 文件 *.c, *.cc, *.cp, *.cxx, *.cpp, *.CPP,
                                      *.c++, *.C, *.i, *.ii

  comment.file-description-header  : 所有文件类型为 'c' 或 'cpp'

同样，适当的模板将会被包含进一个新文件。这由插件根据文件扩展名来决定。默认
显示上述模板。你可以在 '~/.vimrc' 中设置一个全局变量来改变这个扩展名列表。

  au BufRead,BufNewFile  *.XYZ  set filetype=c

  let g:C_SourceCodeExtensions  = 'XYZ c cc cp cxx cpp CPP c++ C i ii'

新文件 'test.XYZ' 将会被认为是一个 C 的实现文件。

------------------------------------------------------------------------------

1.1.6  文件区块注释                                   *csupport-comm-sections*

文件区块注释可以用相似风格的注释来分隔典型的 C 和 H 文件区块，如:

/* #####   HEADER FILE INCLUDES   ################################################### */

/* #####   MACROS  -  LOCAL TO THIS SOURCE FILE   ################################### */

/* #####   TYPE DEFINITIONS  -  LOCAL TO THIS SOURCE FILE   ######################### */

在 C/C++ 文件中，也可以使用快捷键 \ccs 来插入这些区块注释，或是在头文件中使用 \chs。
这些快捷键会在命令栏执行 'CFileSection' 或 'HFileSection':

 :CFileSection
 :HFileSection

现在，按下 <Tab> 键显示选项菜单，并从中挑一个吧。

------------------------------------------------------------------------------

1.1.7  关键字注释，特殊注释                            *csupport-comm-keyword*

关键字注释是行尾注释:

 /* :<关键字>:<date+time>:<author reference>: <arbitrary comment text> */

关键字包括:

 BUG COMPILER TODO TRICKY WARNING WORKAROUND 用户自定义关键字

这些预备注释是用于标注快速恢复工作的位置。它们通常意味着不是为了最终文档。这些
注释可以很容易地通过关键字搜索到。
关键字注释也可以使用快捷键 \ckc。这个快捷键会在命令栏运行命令 "KeywordComment":

 :KeywordComment

现在按下 <Tab> 调出选择菜单来挑一个。

特别注释偶尔用于在一段代码构成中注明特别的特性（如:在一个switch语句中失败的
情况， 一个空循环）:

 /* EMPTY */
 /* NOT REACHED */
 /* REMAINS TO BE IMPLEMENTED */
  ....

特殊注释也可以使用快捷键 \csc。这个快捷键会在命令栏运行命令 "KeywordComment":

 :SpecialComment

现在按下 <Tab> 调出选择菜单来挑一个。

------------------------------------------------------------------------------

1.1.8  标签 (插件)                                        *csupport-comm-tags*

'tags (plugin)' 子菜单可以让你从模板系统（参见 |csupport-templates-macros|）插入
预定义的宏 template system（参见 |csupport-templates-macros|）。在可视模式下，
宏会替换被标记的文本。

------------------------------------------------------------------------------

1.1.9  日期和日期+时间                                    *csupport-comm-date*

'date' 和 'date time' 可以由用户来定义（参见 |csupport-templates-date|）。在可视
模式下，宏会替换被标记的文本（如: 更新日期和时间）。

------------------------------------------------------------------------------

1.1.10 C 注释转 C++ 注释，反之亦然                       *csupport-comm-c-cpp*

菜单项 "// xxx -> /* xxx */" 将 C++ 注释转换成 C 注释。这可以在正常模式或插入模
式的 当前行和可视模式的标记块中完成。
如果有多个 C 注释，则只有第一个会被转换:
  printf ("\n");                     /* one */ /* two */ /* three */
会变成
  printf ("\n");                     // one  /* two */ /* three */

菜单项 "/* xxx */ -> // xxx" 将 C 注释转换成 C++ 注释。

------------------------------------------------------------------------------
1.2  'Statements' 菜单                                          *csupport-stat*
------------------------------------------------------------------------------

1.2.1  正常模式，插入模式                          *csupport-stat-normal-mode*

将会插入一条空语句并适当缩进。菜单项 "if{}" 将会插入一条 if 语句:

if (  )
{
}


1.2.2  可视模式                                    *csupport-stat-visual-mode*

带代码块的语句和 case 标签
--------------------------------------
高亮区域

xxxxx
xxxxx

将会被以下语句之一环绕:

  +----------------------------+-----------------------------+
  |     if (  )                |     if (  )                 |
  |     {                      |     {                       |
  |       xxxxx                |       xxxxx                 |
  |       xxxxx                |       xxxxx                 |
  |     }                      |     }                       |
  |                            |     else                    |
  |                            |     {                       |
  |                            |     }                       |
  +----------------------------+-----------------------------+
  |     for ( ; ;  )           |     while (  )              |
  |     {                      |     {                       |
  |       xxxxx                |       xxxxx                 |
  |       xxxxx                |       xxxxx                 |
  |     }                      |     }                       |
  +----------------------------+-----------------------------+
  |     do                     |                             |
  |     {                      |     {                       |
  |       xxxxx                |       xxxxx                 |
  |       xxxxx                |       xxxxx                 |
  |     }                      |     }                       |
  |     while (  );            |                             |
  +----------------------------+-----------------------------+
  |      switch (  ) {                                       |
  |      case :                                              |
  |       break;                                             |
  |                                                          |
  |      case :                                              |
  |       break;                                             |
  |                                                          |
  |      case :                                              |
  |       break;                                             |
  |                                                          |
  |      case :                                              |
  |       break;                                             |
  |                                                          |
  |      default:                                            |
  |       break;                                             |
  |      }                                                   |
  +----------------------------+-----------------------------+

整个语句在插入后会进行缩进。


不带代码块的语句
--------------------------
将会插入以下语句之一

  +-------------------------------+--------------------------+
  |    if (  )                    |    for ( ; ;  )          |
  +-------------------------------+--------------------------+
  |    if (  )                    |    while (  )            |
  |    else                       |                          |
  +-------------------------------+--------------------------+
  |    case :                     |                          |
  |      break;                   |                          |
  +-------------------------------+--------------------------+


------------------------------------------------------------------------------
1.3  'Preprocessor' 菜单                                        *csupport-prep*
------------------------------------------------------------------------------

1.3.1  正常模式，插入模式                          *csupport-prep-normal-mode*

将会插入预处理器语句并适当缩进。

1.3.2  可视模式                                    *csupport-prep-visual-mode*

带代码块的语句
----------------------
高亮区域

xxxxx
xxxxx

将会被以下语句之一环绕:

  +----------------------------+-----------------------------+
  |    #if  CONDITION                                        |
  |    xxxxx                                                 |
  |    xxxxx                                                 |
  |    #else      /* ----- #if CONDITION  ----- */           |
  |                                                          |
  |    #endif     /* ----- #if CONDITION  ----- */           |
  +----------------------------------------------------------+
  |    #ifdef  CONDITION                                     |
  |    xxxxx                                                 |
  |    xxxxx                                                 |
  |    #else      /* ----- #ifdef CONDITION  ----- */        |
  |                                                          |
  |    #endif     /* ----- #ifdef CONDITION  ----- */        |
  +----------------------------------------------------------+
  |    #ifndef  CONDITION                                    |
  |    xxxxx                                                 |
  |    xxxxx                                                 |
  |    #else      /* ----- #ifndef CONDITION  ----- */       |
  |                                                          |
  |    #endif     /* ----- #ifndef CONDITION  ----- */       |
  +----------------------------------------------------------+
  |    #ifndef  INC_TEST                                     |
  |    #define  INC_TEST                                     |
  |    xxxxx                                                 |
  |    xxxxx                                                 |
  |    #endif   /* ----- #ifndef INC_TEST  ----- */          |
  +----------------------------------------------------------+
  |    #if  0     /* ----- #if 0 : If0Label_1 ----- */       |
  |                                                          |
  |    #endif     /* ----- #if 0 : If0Label_1 ----- */       |
  +----------------------------------------------------------+

作为一个建议，包含防护的宏名字（如上 INC_TEST）将由文件名得来。

1.3.3  用 "#if 0 ... #endif" 封闭代码                      *csupport-prep-if0*

菜单项 "#if 0 #endif" 插入行

  #if  0     /* ----- #if 0 : If0Label_1 ----- */

  #endif     /* ----- #if 0 : If0Label_1 ----- */

在可视模式下，标记的代码块会被这些行包围。

这通常用来暂时封闭一些代码。像标签名 If0Label_1 是自动插入到代码中的。尾部的数字
是自动递增的。用户可以修改这些数字。下一个数字将会比当前缓冲区中最大的数字还要
大一。

对应的标签可以使用 vim 的星号命令（*）来搜索到。所有的标签都可以使用全局搜索，像
:g/If0Label_/ 或 :g/If0Label_\d\+/ 。所有对应的行都可以使用 :g/If0Label_/d删除。


去除包围结构 "#if 0 ... #endif"

如果光标位于这样的段落中间或者在邻近的两行之上，菜单项 'remove #if #endif' 将会
删除这个结构。原生的结构不会受到影响。

1.3.4  外部命令                                         *csupport-prep-ex*

有 4 个附加的外部命令可以用来插入包含语句:

 外部命令               快捷键     包含
 -------------------------------------------------------------------------
 :IncludeStdLibrary     \ps        C 标准库
 :IncludeC99Library     \pc        C99 库
 :IncludeCppLibrary     \+ps       C++ 标准库
 :IncludeCppCLibrary    \+pc       C 标准库 ( #include <c...> )

键入 :Inc<Tab> 来选择一个命令。现在，键入一个额外的空格和一个 <Tab> 来显示全部
列表或是键入一个空格和几个首字符以减小这个列表。

------------------------------------------------------------------------------
1.4  'Idioms' 菜单                                           *csupport-idioms*
------------------------------------------------------------------------------

1.4.1  'function' 项                                *csupport-idioms-function*

正常模式，插入模式:
提供函数名字后，以下行（用于函数名 "f"）将会插入。

  void
  f (  )
  {
    return ;
  }        /* ----------  end of function f  ---------- */

可视模式:
Main 或 [ 静态 ] 函数: 高亮行会在新函数或 main 函数里面。
for 循环: 高亮行会放在花括号内。

1.4.2  for 循环控制                               *csupport-idioms-for-loop*

菜单项 'for( x=0; ... )' 和 'for( x=n-1; ... )' 可以用来为 for 循环的正向或
反向计数写一个控制语句。这些菜单项会打开一个输入对话框

 [TYPE (expand)] VARIABLE [START [END [INCR.]]] :

至少要提供循环变量名。其它参数为可选。类型被限制为以下整数数据类型:

  char
  int
  long
  long int
  long long
  long long int
  short
  short int
  size_t
  unsigned
  unsigned char
  unsigned int
  unsigned long
  unsigned long int
  unsigned long long
  unsigned long long int
  unsigned short
  unsigned short int

任一类型都可以通过键入全部类型名，0 个或多个字符，然后使用 <Tab> 键来补全。
如果类型名的开头是有歧义的 (如: 'uns')，可以通过提供的候选补全列表来选择。

1.4.3  'open input file' 项                           *csupport-idioms-input*

'open input file' 会创建语句来打开和关闭输入文件（如: 通过文件指针 'infile'）。

1.4.4  'open output file' 项                         *csupport-idioms-output*

'open output file' 会创建语句来打开和关闭输出文件（如: 通过文件指针 'outfile'）。

------------------------------------------------------------------------------
1.5  'Snippets' 菜单                                       *csupport-snippets*
------------------------------------------------------------------------------

1.5.1  代码片断

代码片断就是一小部分代码，以独立文件的形式保存在特定目录下（如: 几行代码或一个
Makefile 的完全模板）。
文件名是用于区分这些代码片断。片断目录在安装过程中创建（默认值为
$HOME/.vim/codesnippets-c）。
片断由 Snippets 子菜单下的 3 个菜单项管理。

   C/C++ -> Snippets -> read  code snippet
   C/C++ -> Snippets -> write code snippet
   C/C++ -> Snippets -> edit  code snippet


创建新代码片断
如果没有标记区域，"write code snippet" 将整个缓冲区写入到一个片断文件，否则只有
标记的区域会被写入文件。

插入代码片断
从片断目录（"read code snippet"）选择相应的文件，插入的行会自动缩进。

编辑代码片断
这是一个正常的文本编辑。

缩进 / 不缩进
代码片断通常会在插入后缩进。为了阻止缩进，在缩进文件名后增加扩展名 "ni" 或
"noindent"，如

  parameter_handling.c.noindent

片断浏览器
---------------
在 GUI 下会提供一个打开文件对话框。没有 GUI 则会从命令行读取文件名。你可以通过
在你的 ~/.vimrc 中设置一个全局变量来改变这个行为。

 let g:C_GuiSnippetBrowser = 'commandline'

默认值是 'gui'。


1.5.2   原型拾取                                              *csupport-proto*

原型拾取。
根据函数头部来做一个原型，标记函数头，选择 'Snippets -> pick up prototype'。
原型

  void print_double_array ( double array[], int n, int columns, char* arrayname );

的前六行

   void
  print_double_array (  double array[],  /* array to print                */
                        int    n,        /* number of elements to print   */
                        int    columns,  /* number of elements per column */
                        char*  arrayname /* array name                    */
                        )
  {
    ...
  }       /* ----------  end of function print_double_array  ---------- */


产生出来，并放置在一个内部的缓冲区。
- 去掉了头部和尾部空格。
- 所有内部空格都被压缩了。
- 所有注释会被丢弃。
- 函数体尾部（如 '{'）也会被去除。
- 类名和范围解析符会被去除（C++ 方法定义）。
可以拾取更多的原型并收集到同一个缓冲区。

对于 C++ 方法，命令空间的名字和类名都会被删除。（例外: 'std::'）。下列前两行

  std::string
  ROBOT::Robot::get_name  ( void )
  {
    return type_name;
  }   /* -----  end of method Robot::get_name  ----- */

会得到原型

  std::string get_name ( void );

代码折叠有利于原型拾取（见 |csupport-folding|）。


插入原型
随着 'Snippets -> insert prototype(s)'，所有当前缓冲区中拾取的原型会被插入到
光标后。
原型缓冲区会在插入后清空。


丢弃原型
随着 'Snippets -> clear prototype(s)'，原型缓冲区将会被清空。


展现原型
收集的原型列表由 'Snippets -> show prototype(s)' 展现。序号和文件名都会被显示。
如:

  (1) matrix.c #  double** calloc_double_matrix ( int rows, int columns );
  (2) matrix.c #  void free_double_matrix ( double **m );
  (3) foomain.c #  void foo ( );


注意。产生原型这种方式在小项目中很好。你可能想用一个像 cextract 或其它之类的
提取器。


1.5.3  代码模板                                      *csupport-templates-menu*
---------------------
几乎所有的菜单入口都插入代码片断或注释。所有这些东西都是从模板文件中读取，并且
可以由用户修改以满足他的需求（见 |csupport-templates| 如何使用模板系统）。

菜单项 'edit local templates' 会打开本地插件安装目录中的主模板文件。
通常是 '~/.vim/c-support/templates/Templates'。这取决于从主文件中加载的文件。
现在，修改你想改的任何文件并保存，然后点击菜单项 'reread templates' 读取文件，
来重建模板的内部表现。

菜单项 'edit global templates' 会打开系统插件安装目录中的主模板文件。（见
|csupport-system-wide|）。通常是 '$VIM./vimfiles/c-support/templates/Templates'.

模板浏览器
----------------
在 GUI 下会提供一个打开文件对话框。没有 GUI 则会从命令行读取文件名。你可以通过
在你的 ~.vimrc 中设置一个全局变量来改变这个行为:

 let g:C_GuiTemplateBrowser = 'explorer'

默认值为 'gui'。 'explorer' 会打开一个文件浏览器（见帮助 |:Explore|）。使用命令
行则设置为 'commandline'。

------------------------------------------------------------------------------
1.6  'C++' 菜单                                                 *csupport-c++*
------------------------------------------------------------------------------

1.6.1  正常模式，插入模式。                         *csupport-c++-normal-mode*

将会插入一个空语句，在某些情况下会正常的缩进。菜单项 'try .. catch' 将插入
以下行:

  try {
  }
  catch ( const &ExceptObj ) {    // handle exception:
  }
  catch (...) {   // handle exception: unspecified
  }

光标将会在 try 区块。

1.6.2  可视模式。                                   *csupport-c++-visual-mode*

高亮区域将会被下列语句之一所环绕:

  try - catch
  catch
  catch(...)
  namespace { }
  extern "C" { }

整个语句将会在插入后缩进。

1.6.3   方法实现                                    *csupport-c++-method-impl*

菜单项 'method implement.' 要求提供一个方法名。如果是第一次调用，你将会看到一个
范围解析符。如果你指定了范围，它将会在下次调用时乃至。如果你使用了其中的一个
菜单项来产生一个类（见 |csupport-templates|），这个范围将会被提取并用于下一个
方法。

1.6.4  外部命令                                              *csupport-c++-ex*

一共有 4 个外部命令可以用来插入 include 语句。见 |csupport-prep-ex|.

------------------------------------------------------------------------------
1.7  'Run' 菜单                                                 *csupport-run*
------------------------------------------------------------------------------

1.7.1  最小 MAKE 功能                                    *csupport-run-buffer*

'Run' 菜单为单文件项目提供了一个最小 make 功能（如: 在教学中）:

保存和编译
'save and compile' 保存缓冲区，以给定的选项运行编译器
（见 |csupport-custom-glob-vars|）。

如果编译器报告了错误或警告，会打开一个错误显示窗口。这时，Quickfix 命令可以用于
跳转到一个错误产生的位置。

请考虑在你的 ~/.vimrc 文件中使用类似映射
  map  <silent> <F7>    <Esc>:cprevious<CR>
  map  <silent> <F8>    <Esc>:cnext<CR>
跳过错误的位置，便导航更加容易。错误列表和错误位置会在源文件缓冲区中保持同步。



目标文件的扩展名可以在 ~.vimrc 中设置:

  let g:C_ObjExtension = '.obj'

默认为 '.o'（'.obj' 适用于 Windows）。

链接
'link' 从当前缓冲区创建一个可执行程序。如果缓冲区没有保存，或者没有可用目标文件
或者目标文件早于源文件，则首先执行 'save and compile'。
只有当前缓冲区里包含一个 main 函数，才会尝试进行链接。

编译器 / 链接器的行为取决于对选项的赋值，选项描述见 |csupport-custom-glob-vars|
（第三组）。

运行
'run' 执行与当前缓冲区名字相同的可执行程序。如果缓冲区没有保存，或都没有可执行
文件，或者可执行程序早于源文件，则首先执行 'save and compile' 和 'link'。

可执行程序的扩展名可以在 ~.vimrc 中设置:

  let g:C_ExeExtension = '.exe'

默认是空字符串。

1.7.2  命令行参数                                  *csupport-run-cmdline-args*

菜单项 'command line arguments' 调用一个输入对话框来请求命令行参数。这些参数会
被转发到由菜单项 'run' 运行的程序。除非你改变，否则参数会一直保留。
对于第一个并且是唯一的参数时，将会进行文件名扩展（使用 <Tab> 键）。由于 Vim
输入功能的限制，只有输入的第一个字符串才会被扩展。如果要扩展两个或更多的文件名
，可以按倒序来指定它们: 输入最后一个文件名的首字符并扩展，回到输入的起点，输入
倒数第二个文件名的开始并扩展它。

该参数属于当前的缓冲区（也就是说，每个缓冲区都能有自己的参数）。
如果缓冲区通过 "save as" 得到一个新名字，参数将会属于使用新名字的缓冲区。

命令行参数可以带有管道符和重定向符:

  11 22 | sort -rn | head -10 > out

警告: 如果你想通过再次调用这个菜单项来查看当前参数，请确保离开时使用回车（而
不是 Esc !）。由于 Vim 函数内部的限制，回车保留参数，Esc 会丢弃它们。


1.7.3  运行 make                                           *csupport-run-make*

菜单项 'make' 运行外部的 make 程序。如果编译器或链接器在 make 过程中报告错误或
警告，将会打开一个错误窗口。Quickfix 命令可以用于跳转到一个错误位置。

当位于一个 makefile 中，快捷键 \rm，\rmc，和 \rma 都是可用的（见
|csupport-usage-vim|）。
代码片断集合中包含了一个简单的 makefile，可以简单适用于小项目。
1.7.4  运行可执行程序                                  *csupport-run-make-run*

菜单项 'executable to run' 要求提供由 make 创建的可执行程序的名字。如果给定的
名字不为空，可执行程序将由菜单项 'run'（\rr，C-F9）来运行。
调用 'excutable to run' 时删除名字将回到默认行为（见 |csupport-run-buffer|）。

1.7.5  运行 make clean                               *csupport-run-make-clean*

菜单项 'make' 使用标准目标 'clean' 运行外部 make 程序 'clean'。


1.7.6  make 的命令行参数                              *csupport-run-make-args*

菜单项 'command line arguments for make' 调用一个输入对话框来请求 make 的命令行
参数。当 make 被菜单项 'make' 调用时，这些参数将被转发。
对于第一个并且是唯一的参数，文件名展开是可用的（使用 <Tab>）。


1.7.7  SPLINT                                            *csupport-run-splint*

Splint 是一个 C 程序静态检查工具（见 http://www.splint.org）。
当然它必须是已安装的以便于在 Vim 中使用。菜单项 'Run->splint' 将会通过 splint
来运行当前缓冲区。

如果 splint 报错，将会打开一个错误窗口，Quickfix 命令可以用于跳转到错误位置。
为了更容易地导航，参见 'SAVE AND COMPILE' |csupport-run-buffer| 底下的提示。

Splint 有很多选项。意味着将这些选项保存到一个选项文件（~/.splintrc）是最好的
办法。对于快速尝试，你可以使用菜单项 'Run->cmd. line arg. for splint' 来指定
一些缓冲区相关选项。

当 Vim 启动时，这个插件将检测 Splint 是否为可执行程序，如果不是，该菜单项将不会
显示。


1.7.8  CODECHECK                                      *csupport-run-codecheck*

CodeCheck (TM) 是一个由 Abraxas Software, Inc.  (www.abraxas-software.com) 制作
的商业代码分析工具。
当然它必须是已安装的以便于在 Vim 中使用。菜单项 item 'Run->CodeCheck' 将会通过
CodeCheck 来运行当前缓冲区。

如果 CodeCheck 报错，将会打开一个错误窗口，Quickfix 命令可以用于跳转到错误位置。
为了更容易地导航，参见 'SAVE AND COMPILE' |csupport-run-buffer| 底下的提示。

CodeCheck 有很多选项。对于快速尝试，你可以使用菜单项
'Run->cmd. line arg. for CodeCheck' 来指定一些缓冲区相关选项。

CodeCheck 会使用默认选项启动（见 |csupport-custom-glob-vars|）。默认选项可以
通过在 ~/.vimrc 中设置一个全局变量来覆盖。如:

  let  g:C_CodeCheckOptions = "-K13 -Rmeyers"

默认的可执行程序名字为 'check'。在不同的平台会使用一些其它的名字。可以在
~/.vimrc 中设置一个全局变量来修改这个名字，如:

  let  g:C_CodeCheckExeName = "chknt.exe"

当 Vim 启动时，这个插件将检查 CodeCheck 是否为可执行程序，如果不是，该菜单项将
不会显示。


1.7.9  INDENT                                            *csupport-run-indent*

The formatter 'indent' can be run over the whole buffer.  Before formatting a
buffer this buffer will be saved to disk and you will be asked for a
confirmation.

Indent has many options. These are kept in the file '.indent.pro' in your home
directory. See the indent manual for more information.


1.7.10  HARDCOPY                                       *csupport-run-hardcopy*

Generates a PostScript file from the whole buffer or from a marked region.
On a Windows system a printer dialog is displayed.
The hardcopy goes to the current working directory.  If the buffer contains
documentation or other material from non-writable directories the hardcopy
goes to the HOME directory. The output destination will be shown in a message.

The print header contains date and time for the current locale. The definition
used is

  let s:C_Printheader = "%<%f%h%m%<  %=%{strftime('%x %X')}     Page %N"

The current locale can be overwritten by changing the language, e.g.

  :language C

or by setting a global variable in the file ~/.vimrc , e.g. :

  let g:C_Printheader = "%<%f%h%m%<  %=%{strftime('%x %X')}     SEITE %N"

See :h printheader and :h strftime()  for more details.


1.7.11  REBUILD TEMPLATES                             *csupport-run-templates*

After editing one or more template files  a click on this item rereads the
template files and rebuilds all templates.


1.7.12  XTERM SIZE                                        *csupport-run-xterm*

The size of the xterm used for  running a program (below) can be set by this
menu item. The default is 80 columns with 24 lines.
This feature is not available under Windows.


1.7.13  OUTPUT REDIRECTION                               *csupport-run-output*

Running a program can be done in one of three ways:
(1) Run the program from the gVim command line.
    This is for interactive programs with little input and output.
(2) Run the program and direct the output into a window with name "C-Output".
    The buffer and its content will disappear when the window is closed and
    reused otherwise.
    This is for non-interactive programs with little to very much output.
    You have unlimited line length, regex search, navigation, ...
    The tabstop value will be set to 8  for "C-Output".
(3) Run the program in an xterm.

The output method can be chosen from the menu item 'Run->output: ...'.
This menu has three states:

  output: VIM->buffer->xterm
  output: BUFFER->xterm->vim
  output: XTERM->vim->buffer

The first (uppercase) item shows the current method.  The default is 'vim'.
This can be changed by setting the variable g:C_OutputGvim to another value.
Possible values are 'vim', 'buffer' and 'xterm' .

The xterm defaults can be set in ~/.vimrc by the variable g:C_XtermDefaults .
The default is "-fa courier -fs 12 -geometry 80x24" :
  font name     : -fa courier
  font size     : -fs 12
  terminal size : -geometry 80x24
See 'xterm -help' for more options. Xterms are not available under Windows.

------------------------------------------------------------------------------
1.8  'help'                                                    *csupport-help*
------------------------------------------------------------------------------
Plugin help
-----------
The root menu item 'help (plugin)' shows this plugin help in a help window.
The help tags must have been generated with
  :helptags ~/.vim/doc
The hotkey is \hp (for "help plugin").

Displaying a manual
-------------------
The root menu item 'show manual' shows the manual for the word under the
cursor. If there is more than one manual a selection list will be presented.
If there is no word under the cursor you can type in a name.  An interface to
the on-line reference manuals must be installed (usually man(1) for
Linux/Unix, see|csupport-custom-glob-vars|).
The hotkey is \hm (for "help manual").

==============================================================================
2.  USAGE WITHOUT GUI  (Vim)                              *csupport-usage-vim*
==============================================================================

The frequently used constructs can be inserted with key mappings.  The
mappings are also described in the document c-hot-keys.pdf (reference card,
part of this package).
Hint: Typing speed matters. The combination of a leader ('\') and the
following character(s) will only be recognized for a short time.
The insert mode mappings start with ` (backtick).

Legend:  (i) insert mode, (n) normal mode, (v) visual mode

  -- Help ---------------------------------------------------------------

  \hm       show manual for word under the cursor (n,i)
  \hp       show plugin help                      (n,i)

  -- Comments -----------------------------------------------------------

  \cl       end-of-line comment                 (n,v,i)
  \cj       adjust end-of-line comment(s)       (n,v,i)
  \cs       set end-of-line comment column      (n)
  \c*       code -> comment /* */               (n,v)
  \cc       code -> comment //                  (n,v)
  \co       comment -> code                     (n,v)
  \cfr      frame comment                       (n,i)
  \cfu      function comment                    (n,i)
  \cme      method description                  (n,i)
  \ccl      class description                   (n,i)
  \cfdi     file description (implementation)   (n,i)
  \cfdh     file description (header)           (n,i)
  \ccs      C/C++-file section  (tab. compl.)   (n,i)
  \chs      H-file section      (tab. compl.)   (n,i)
  \ckc      keyword comment     (tab. compl.)   (n,i)
  \csc      special comment     (tab. compl.)   (n,i)
  \cd       date                                (n,v,i)
  \ct       date \& time                        (n,v,i)

  -- Statements ---------------------------------------------------------

  \sd       do { } while                        (n,v,i)
  \sf       for                                 (n,i)
  \sfo      for { }                             (n,v,i)
  \si       if                                  (n,i)
  \sif      if { }                              (n,v,i)
  \sie      if else                             (n,v,i)
  \sife     if { } else { }                     (n,v,i)
  \se       else { }                            (n,v,i)
  \sw       while                               (n,i)
  \swh      while { }                           (n,v,i)
  \ss       switch                              (n,v,i)
  \sc       case                                (n,i)
  \s{ \sb   { }                                 (n,v,i)

  -- Preprocessor -------------------------------------------------------

  \ps       choose a standard library include   (n,i)
  \pc       choose a C99 include                (n,i)
  \p<       #include <>                         (n,i)
  \p"       #include ""                         (n,i)
  \pd       #define                             (n,i)
  \pu       #undef                              (n,i)
  \pie      #if  #else #endif                   (n,v,i)
  \pid      #ifdef #else #endif                 (n,v,i)
  \pin      #ifndef #else #endif                (n,v,i)
  \pind     #ifndef #def #endif                 (n,v,i)
  \pi0      #if 0 #endif                        (n,v,i)
  \pr0      remove #if 0 #endif                 (n,i)
  \pe       #error                              (n,i)
  \pl       #line                               (n,i)
  \pp       #pragma                             (n,i)

  -- Idioms -------------------------------------------------------------

  \if       function                            (n,v,i)
  \isf      static function                     (n,v,i)
  \im       main()                              (n,v,i)
  \i0       for( x=0; x<n; x+=1 )               (n,v,i)
  \in       for( x=n-1; x>=0; x-=1 )            (n,v,i)
  \ie       enum   + typedef                    (n,i)
  \is       struct + typedef                    (n,i)
  \iu       union  + typedef                    (n,i)
  \ip       printf()                            (n,i)
  \isc      scanf()                             (n,i)
  \ica      p=calloc()                          (n,i)
  \ima      p=malloc()                          (n,i)
  \isi      sizeof()                            (n,v,i)
  \ias      assert()                            (n,v)
  \ii       open input file                     (n,i)
  \io       open output file                    (n,i)

  -- Snippets -----------------------------------------------------------

  \nr       read code snippet                   (n,i)
  \nw       write code snippet                  (n,v,i)
  \ne       edit code snippet                   (n,i)
  \np       pick up prototype                   (n,v,i)
  \ni       insert prototype(s)                 (n,i)
  \nc       clear  prototype(s)                 (n,i)
  \ns       show   prototype(s)                 (n,i)
  \ntl      edit local templates                (n,i)
  \ntg      edit global templates               (n,i)
  \ntr      rebuild templates                   (n,i)

  -- C++ ----------------------------------------------------------------

  \+co      cout  <<  << endl;                  (n,i)
  \+"       << ""                               (n,i)
  \+c       class                               (n,i)
  \+ps      #include <...> STL                  (n,i)
  \+pc      #include <c..> C                    (n,i)
  \+cn      class (using new)                   (n,i)
  \+ci      class implementation                (n,i)
  \+cni     class (using new) implementation    (n,i)
  \+mi      method implementation               (n,i)
  \+ai      accessor implementation             (n,i)

  \+tc      template class                      (n,i)
  \+tcn     template class (using new)          (n,i)
  \+tci     template class implementation       (n,i)
  \+tcni    template class (using new) impl.    (n,i)
  \+tmi     template method implementation      (n,i)
  \+tai     template accessor implementation    (n,i)

  \+tf      template function                   (n,i)
  \+ec      error class                         (n,i)
  \+tr      try ... catch                       (n,v,i)
  \+ca      catch                               (n,v,i)
  \+c.      catch(...)                          (n,v,i)

  -- Run ----------------------------------------------------------------

  \rc       save and compile                    (n,i)
  \rl       link                                (n,i)
  \rr       run                                 (n,i)
  \ra       set comand line arguments           (n,i)
  \rm       run make                            (n,i)
  \rmc      run 'make clean'                    (n,i)
  \rme      executable to run                   (n,i)
  \rma      cmd. line arg. for make             (n,i)
  \rp       run splint                          (n,i)
  \rpa      cmd. line arg. for splint           (n,i)
  \rk       run CodeCheck (TM)                  (n,i)
  \rka      cmd. line arg. for CodeCheck (TM)   (n,i)
  \rd       run indent                          (n,v,i)
  \rh       hardcopy buffer                     (n,v,i)
  \rs       show plugin settings                (n,i)
  \rx       set xterm size                      (n, only Linux/UNIX & GUI)
  \ro       change output destination           (n,i)

  -- Load / Unload C/C++ Support ----------------------------------------

  \lcs      Load C/C++ Support Menus            (n, GUI only)
  \ucs      Unload C/C++ Support Menus          (n, GUI only)

The hotkeys are defined in the file type plugin c.vim (part of this csupport
plugin package) and described in the document c-hot-keys.pdf

Changing the default map leader '\'
-----------------------------------
The map leader can be changed by the user by setting a global variable in the
file .vimrc

 let g:C_MapLeader  = ','

The map leader is now a comma. The 'line end comment' command is now defined
as ',cl'. This setting will be used as a so called local leader and influences
only files with filetype 'c' and 'cpp'.

==============================================================================
3.  HOTKEYS                                                 *csupport-hotkeys*
==============================================================================

The following hotkeys are defined in normal, visual and insert mode:

       F9   compile and link
   Alt-F9   write buffer and compile
  Ctrl-F9   run executable
 Shift-F9   set command line arguments

 Shift-F2   switch between source files and header files

The hotkeys are defined in the file type plugin  c.vim.  All hotkeys from the
non-GUI mode also work for gVim (see |csupport-usage-vim|).

Shift-F2 can be used to switch between source files and header files if the
plugin a.vim (http://vim.sourceforge.net/scripts/script.php?script_id=31) is
present.  To suppress the creation of a new header file when switching from a
source file the file ~/.vimrc should contain a line

  let g:alternateNoDefaultAlternate = 1

A header file will only be opened if it already exists.

The Shift-key is dead when you are working with Vim in a console terminal
(non-Gui). You could add

  noremap   \a        :A<CR>
 inoremap   \a   <C-C>:A<CR>

to get a hot key for this case.

==============================================================================
4.  CUSTOMIZATION                                            *csupport-custom*
==============================================================================

------------------------------------------------------------------------------
4.1  GLOBAL VARIABLES                              *csupport-custom-glob-vars*
------------------------------------------------------------------------------

Several global variables are checked by the script to customize it:

  ----------------------------------------------------------------------------
  GLOBAL VARIABLE           DEFAULT VALUE                    TAG (see below)
  ----------------------------------------------------------------------------
  g:C_GlobalTemplateFile     plugin_dir.'c-support/templates/Templates'
  g:C_LocalTemplateFile      $HOME.'/.vim/c-support/templates/Templates'
  g:C_TemplateOverwrittenMsg 'yes'
  g:C_Ctrl_j                 'on'

  g:C_CodeSnippets           plugin_dir.'/c-support/codesnippets/'
  g:C_Dictionary_File        ''
  g:C_LoadMenus              'yes'
  g:C_MenuHeader             'yes'
  g:C_OutputGvim             'vim'
  g:C_Root                   '&C\/C\+\+.'
  g:C_XtermDefaults          '-fa courier -fs 12 -geometry 80x24'
  g:C_Printheader            "%<%f%h%m%<  %=%{strftime('%x %X')}     Page %N"
  g:C_MapLeader              '\'
  g:C_GuiSnippetBrowser      'gui'
  g:C_GuiTemplateBrowser     'gui'

  Linux/UNIX:
   g:C_ObjExtension          '.o'
   g:C_ExeExtension          ''
   g:C_CCompiler             'gcc'
   g:C_CplusCompiler         'g++'
   g:C_Man                   'man'
  Windows:
   g:C_ObjExtension          '.obj'
   g:C_ExeExtension          '.exe'
   g:C_CCompiler             'gcc.exe'
   g:C_CplusCompiler         'g++.exe'
   g:C_Man                   'man.exe'
  g:C_VimCompilerName        gcc
  g:C_CFlags                 '-Wall -g -O0 -c'
  g:C_LFlags                 '-Wall -g -O0'
  g:C_Libs                   '-lm'
  g:C_LineEndCommColDefault  49
  g:C_CExtension             'c'
  g:C_TypeOfH                'cpp'
  g:C_SourceCodeExtensions   'c cc cp cxx cpp CPP c++ C i ii'

  g:C_CodeCheckExeName       'check'
  g:C_CodeCheckOptions       '-K13'

The variable plugin_dir will automatically be set to one of the following values:
  $HOME.'/.vim/'        for Linux/Unix
  $VIM.'/vimfiles/'     for Windows

  ----------------------------------------------------------------------------

 1. group: g:C_GlobalTemplateFile : Sets the master template file (see|csupport-templates|)
           g:C_LocalTemplateFile  : Sets the local template file  (see|csupport-templates|)
           g:C_TemplateOverwrittenMsg : message if template is overwritten
           g:C_Ctrl_j                 : hotkey Ctrl-j  'on'/'off' (see|csupport-Ctrl-j|)

 2. group: g:C_CodeSnippets       : The name of the code snippet directory
                                   (see |csupport-snippets|).
           g:C_Dictionary_File    : The name(s) of the dictionary file(s) used for
                                    word completion (see also |csupport-dictionary|)
           g:C_LoadMenus          : Load menus and mappings ("yes", "no") at startup.
           g:C_MenuHeader         : Switch the submenu header on/off.
           g:C_OutputGvim         : when program is running output goes to the vim
                                    command line ("vim"), to a buffer ("buffer") or to
                                    an xterm ("xterm").
           g:C_Root               : The name of the root menu entry of this plugin
                                           (see |csupport-custom-root|).
           g:C_XtermDefaults      : the xterm defaults
           g:C_Printheader        : hardcopy: definition of the page header
           g:C_MapLeader          : the map leader for hotkeys (see|csupport-usage-vim|)
           g:C_GuiSnippetBrowser  : code snippet browser: 'gui', 'commandline'
           g:C_GuiTemplateBrowser : code template browser: 'gui', 'explorer', 'commandline'

 3. group: g:C_CExtension             : Extension of C files. Everything else is C++.
           g:C_TypeOfH                : filetype of header files with extension 'h' (c,cpp)
           g:C_SourceCodeExtensions   : filename extensions for C/C++
                                        implementation files
           g:C_CCompiler              : The name of the C compiler.
           g:C_CplusCompiler          : The name of the C++ compiler.
           g:C_VimCompilerName        : the compiler name used by :compiler
           g:C_Man                    : The name of the man utility.
           g:C_CFlags                 : Compiler flags used for a compilation.
           g:C_LFlags                 : Compiler flags used for linkage.
           g:C_Libs                   : Libraries to link with.
           g:C_ObjExtension           : C/C+ file extension for objects
                                        (leading point required if not empty)
           g:C_ExeExtension           : C/C+ file extension for executables
                                        (leading point required if not empty)
           g:C_LineEndCommColDefault  : Default starting column for end-of-line comments.
           g:C_CodeCheckExeName       : The name of the CodeCheck (TM) executable
                                        (the default is 'check')
           g:C_CodeCheckOptions       : Default options for CodeCheck (TM)
                                       (see |csupport-run-codecheck|).

To override the default add appropriate assignments to ~/.vimrc .

------------------------------------------------------------------------------
4.2  THE ROOT MENU                                      *csupport-custom-root*
------------------------------------------------------------------------------

The variable g:C_Root, if set (in '.vimrc' or in '.gvimrc'), gives the name
of the single gVim root menu entry in which the C/C++ submenus will be put.
The default is

  '&C\/C\+\+.'
                  ''
Note the terminating dot.

If you want to set the plugin root menu into another menu, e.g. 'Plugin',
this is done by the following line in '.vimrc'

  let g:C_Root = '&Plugin.&C\/C\+\+.'

------------------------------------------------------------------------------
4.3  SYSTEM-WIDE INSTALLATION                           *csupport-system-wide*
------------------------------------------------------------------------------

A system-wide installation (one installation for all users) is done as
follows.

As *** SUPERUSER *** :

(1) Find the Vim installation directory.
The Vim Ex command ':echo $VIM' gives '/usr/local/share/vim' or something like
that. Beyond this directory you will find the Vim installation,  e.g. in
'/usr/local/share/vim/vim73' if Vim version 7.3 has been installed
(Windows: 'C:\Program Files\Vim').

(2) Create a new subdirectory 'vimfiles', e.g. '/usr/local/share/vim/vimfiles'
(Windows: 'C:\Program Files\Vim\vimfiles').

(3) Install C/C++ Support
Copy the archive cvim.zip to this new directory and unpack it:
  unzip cvim.zip

(4) Generate the help tags:
  :helptags $VIM/vimfiles/doc

SPECIAL CASES. Some Linux distributions use non-standard names for Vim
directories. SUSE has a directory '/usr/share/vim/site' to put plugins in.
These directories will not be found automatically.  After installing the
plugin below '/usr/share/vim/site' the use of the templates will be enabled by
the following line in '~/.vimrc':

  let g:C_GlobalTemplateFile = '/usr/share/vim/site/c-support/templates/Templates'

As *** USER *** :

Create your private snippet directory:

  mkdir --parents  ~/.vim/c-support/codesnippets

You may want to copy the snippets coming with this plugin (in
$VIM/vimfiles/c-support/codesnippets) into the new directory or to set a
link to the global directory.

Create your private template directory:

  mkdir --parents  ~/.vim/c-support/templates

Create a private template file 'Templates' (compulsory) in this directory to
overwrite some macros, e.g.

 *|AUTHOR|*    = your name
 *|AUTHORREF|* = ...
 *|EMAIL|*     = ...
 *|COMPANY|*   = ...
 *|COPYRIGHT|* = ...

You can also have local templates which overwrite the global ones. To suppress
the messages in this case set a global variable in '~/.vimrc' (Windows:
'~\_vimrc') :

  let g:C_TemplateOverwrittenMsg= 'no'

The default is 'yes'.

==============================================================================
5.  TEMPLATE FILES AND TAGS                               *csupport-templates*
==============================================================================

------------------------------------------------------------------------------
5.1  TEMPLATE FILES                                 *csupport-templates-files*
------------------------------------------------------------------------------

Nearly all menu entries insert code snippets or comments. All of these are
contained within template files and can be changed by the user to meet their
requirements.

The master template file is '$HOME/.vim/c-support/templates/Templates' for a
user installation and  '$VIM/vimfiles/c-support/templates/Templates' for a
system-wide installation (see|csupport-system-wide|).

The master template file starts with a macro section followed by templates for
single menu items or better by including other template files grouping the
templates according to the menu structure of this plugin. The master file
could look like this:

  $
  $ =============================================================
  $ ========== USER MACROS ======================================
  $ =============================================================
  $
 *|AUTHOR|*    = Dr. Fritz Mehner
 *|AUTHORREF|* = mn
 *|EMAIL|*     = mehner@fh-swf.de
 *|COMPANY|*   = FH Südwestfalen, Iserlohn
 *|COPYRIGHT|* = Copyright (c)*|YEAR|,|AUTHOR|*
  $
  $ =============================================================
  $ ========== FILE INCLUDES ====================================
  $ =============================================================
  $
 *|includefile|* = c.comments.template
 *|includefile|* = c.cpp.template
 *|includefile|* = c.idioms.template
 *|includefile|* = c.preprocessor.template
 *|includefile|* = c.statements.template

Lines starting with a dollar sign are comments. The section starting
with *|AUTHOR|* assigns values to predefined tags
(see|csupport-templates-macros|) to personalize some templates. Other
predefined tags with given default values can be used (e.g. *|YEAR|* ).

User defined tags are possible. They have the following syntax:

 *|macroname|* = replacement

A macroname starts with a letter (uppercase or lowercase) followed by zero or
more letters, digits or underscores.

------------------------------------------------------------------------------
5.2  MACROS                                        *csupport-templates-macros*
------------------------------------------------------------------------------

The following macro names are predefined. The first group is used to
personalize templates.

 ----------------------------------------------------------------------------
 PREDEFINED MACROS  DEFAULT VALUE
 ----------------------------------------------------------------------------
*|AUTHOR|*          ""
*|AUTHORREF|*       ""
*|EMAIL|*           ""
*|COMPANY|*         ""
*|PROJECT|*         ""
*|COPYRIGHTHOLDER|* ""
*|STYLE|*           ""
*|includefile|*     ""

*|BASENAME|*        filename without path and suffix
*|DATE|*            the preferred date representation for the current locale
                    without the time
*|FILENAME|*        filename without path
*|PATH|*            path without filename
*|SUFFIX|*          filename suffix
*|TIME|*            the preferred time representation for the current locale
                    without the date and the time zone or name or abbreviation
*|YEAR|*            the year as a decimal number including the century

The macro *|includefile|* can  be used to include an additional template file.
A file will be included only once. Commenting and uncommenting include macros
is a simple way to switch between several sets of templates (see also
|csupport-run-templates|). Overwriting existing macros and templates is
possible.

 ----------------------------------------------------------------------------
 PREDEFINED TAGS
 ----------------------------------------------------------------------------
 <CURSOR>,{CURSOR}    The cursor position after insertion of a template
 <+text+>,<-text->,   Jump targets in templates. Jump with Ctrl-j.
 {+text+},{-text-}    See |csupport-templates-jump|.

 <SPLIT>              The split point when inserting in visual mode
                      (see|csupport-templates-definition|)

A dependent template file can start with its own macro section. There is no
need to have all user defined macros in the master file.
When the first template definition is found (see below) macro definitions are
no longer recognized.
Use the tag variant with curly braces if the indentation of the following line
is wrong after template insertion.

------------------------------------------------------------------------------
5.2.1  USER DEFINED FORMATS FOR DATE AND TIME        *csupport-templates-date*
------------------------------------------------------------------------------
The format for *|DATE|* ,*|TIME|* , and*|YEAR|* can be set by the user. The
defaults are
    *|DATE|*        '%x'
    *|TIME|*        '%X'
    *|YEAR|*        '%Y'
See the manual page of the C function strftime() for the format.  The accepted
format depends on your system, thus this is not portable!  The maximum length
of the result is 80 characters.

User defined formats can be set using the following global variables in
~/.vimrc ,  e.g.
    let g:C_FormatDate            = '%D'
    let g:C_FormatTime            = '%H:%M'
    let g:C_FormatYear            = 'year %Y'

------------------------------------------------------------------------------
5.3  TEMPLATES                                      *csupport-templates-names*
------------------------------------------------------------------------------

5.3.1  Template names

The template behind a menu entry is identified by a given name. The first part
of the name identifies the menu, the second part identifies the item. The
modes are also hard coded (see|csupport-templates-definition|for the use of
<SPLIT>).

  TEMPLATE NAME                                              MODES
 --------------------------------------------------------------------------

  comment.class                                              normal
  comment.end-of-line-comment                                normal
  comment.file-description                                   normal
  comment.file-description-header                            normal
  comment.file-section-cpp-class-defs                        normal
  comment.file-section-cpp-class-implementations-exported    normal
  comment.file-section-cpp-class-implementations-local       normal
  comment.file-section-cpp-data-types                        normal
  comment.file-section-cpp-function-defs-exported            normal
  comment.file-section-cpp-function-defs-local               normal
  comment.file-section-cpp-header-includes                   normal
  comment.file-section-cpp-local-variables                   normal
  comment.file-section-cpp-macros                            normal
  comment.file-section-cpp-prototypes                        normal
  comment.file-section-cpp-typedefs                          normal
  comment.file-section-hpp-exported-class-defs               normal
  comment.file-section-hpp-exported-data-types               normal
  comment.file-section-hpp-exported-function-declarations    normal
  comment.file-section-hpp-exported-typedefs                 normal
  comment.file-section-hpp-exported-variables                normal
  comment.file-section-hpp-header-includes                   normal
  comment.file-section-hpp-macros                            normal
  comment.frame                                              normal
  comment.function                                           normal
  comment.keyword-bug                                        normal
  comment.keyword-compiler                                   normal
  comment.keyword-keyword                                    normal
  comment.keyword-todo                                       normal
  comment.keyword-tricky                                     normal
  comment.keyword-warning                                    normal
  comment.keyword-workaround                                 normal
  comment.method                                             normal
  comment.special-constant-type-is-long                      normal
  comment.special-constant-type-is-unsigned-long             normal
  comment.special-constant-type-is-unsigned                  normal
  comment.special-empty                                      normal
  comment.special-fall-through                               normal
  comment.special-implicit-type-conversion                   normal
  comment.special-no-return                                  normal
  comment.special-not-reached                                normal
  comment.special-remains-to-be-implemented                  normal

  cpp.accessor-implementation                                normal
  cpp.catch                                                  normal, visual
  cpp.catch-points                                           normal, visual
  cpp.cin                                                    normal
  cpp.class-definition                                       normal
  cpp.class-implementation                                   normal
  cpp.class-using-new-definition                             normal
  cpp.class-using-new-implementation                         normal
  cpp.cout-operator                                          normal
  cpp.cout                                                   normal
  cpp.error-class                                            normal
  cpp.extern                                                 normal, visual
  cpp.method-implementation                                  normal
  cpp.namespace-block                                        normal, visual
  cpp.namespace                                              normal
  cpp.namespace-std                                          normal
  cpp.open-input-file                                        normal
  cpp.open-output-file                                       normal
  cpp.operator-in                                            normal
  cpp.operator-out                                           normal
  cpp.output-manipulator-boolalpha                           normal
  cpp.output-manipulator-dec                                 normal
  cpp.output-manipulator-endl                                normal
  cpp.output-manipulator-fixed                               normal
  cpp.output-manipulator-flush                               normal
  cpp.output-manipulator-hex                                 normal
  cpp.output-manipulator-internal                            normal
  cpp.output-manipulator-left                                normal
  cpp.output-manipulator-oct                                 normal
  cpp.output-manipulator-right                               normal
  cpp.output-manipulator-scientific                          normal
  cpp.output-manipulator-setbase                             normal
  cpp.output-manipulator-setfill                             normal
  cpp.output-manipulator-setiosflag                          normal
  cpp.output-manipulator-setprecision                        normal
  cpp.output-manipulator-setw                                normal
  cpp.output-manipulator-showbase                            normal
  cpp.output-manipulator-showpoint                           normal
  cpp.output-manipulator-showpos                             normal
  cpp.output-manipulator-uppercase                           normal
  cpp.rtti-const-cast                                        normal
  cpp.rtti-dynamic-cast                                      normal
  cpp.rtti-reinterpret-cast                                  normal
  cpp.rtti-static-cast                                       normal
  cpp.rtti-typeid                                            normal
  cpp.template-accessor-implementation                       normal
  cpp.template-class-definition                              normal
  cpp.template-class-implementation                          normal
  cpp.template-class-using-new-definition                    normal
  cpp.template-class-using-new-implementation                normal
  cpp.template-function                                      normal
  cpp.template-method-implementation                         normal
  cpp.try-catch                                              normal, visual

  idioms.assert                                              normal
  idioms.calloc                                              normal
  idioms.enum                                                normal, visual
  idioms.fprintf                                             normal
  idioms.fscanf                                              normal
  idioms.function                                            normal, visual
  idioms.function-static                                     normal, visual
  idioms.main                                                normal, visual
  idioms.malloc                                              normal
  idioms.open-input-file                                     normal
  idioms.open-output-file                                    normal
  idioms.printf                                              normal
  idioms.scanf                                               normal
  idioms.sizeof                                              normal
  idioms.struct                                              normal, visual
  idioms.union                                               normal, visual

  preprocessor.define                                        normal
  preprocessor.ifdef-else-endif                              normal, visual
  preprocessor.if-else-endif                                 normal, visual
  preprocessor.ifndef-def-endif                              normal, visual
  preprocessor.ifndef-else-endif                             normal, visual
  preprocessor.include-global                                normal
  preprocessor.include-local                                 normal
  preprocessor.undefine                                      normal

  statements.block                                           normal, visual
  statements.case                                            normal
  statements.do-while                                        normal, visual
  statements.for-block                                       normal
  statements.for                                             normal
  statements.if-block-else                                   normal, visual
  statements.if-block                                        normal, visual
  statements.if-else                                         normal, visual
  statements.if                                              normal
  statements.switch                                          normal, visual
  statements.while-block                                     normal, visual
  statements.while                                           normal


5.3.2  Template definition                     *csupport-templates-definition*

A template definition starts with a template head line with the following
syntax:

  == templatename == [ position == ]

The templatename is one of the above template identifiers. The position
attribute is optional. Possible attribute values are:

  above     insert the template before the current line
  append    append the template to the current line
  below     insert the template below the current line
  insert    insert the template at the cursor position
  start     insert the template before the first line of the buffer

An example:

  == comment.function ==
  /*
   * ===  FUNCTION  =======================================================
   *         Name:  <CURSOR>
   *  Description:
   * ======================================================================
   */

The definition of a template ends at the next head line or at the end of the
file.

Templates for the visual mode can use <SPLIT>. The text before <SPLIT> will
than be inserted above the marked area, the text after <SPLIT> will be
inserted behind the marked area. An example:

  == statements.if-block-else ==
  if ( <CURSOR> ) {
  <SPLIT>} else {
  }

If applied to the marked block

  xxxxxxxxxxx
  xxxxxxxxxxx

this template yields

  if (  ) {
    xxxxxxxxxxx
    xxxxxxxxxxx
  } else {
  }

The templates with a visual mode are shown in the table under
|csupport-templates-names|.

5.3.3  Template expansion                       *csupport-templates-expansion*

There are additional ways to control the expansion of a template.

USER INPUT
----------
If the usage of a yet undefined user macro starts with a question mark the
user will be asked for the replacement first, e.g. with the following template

  == idioms.function ==
  void<CURSOR>
 *|?FUNCTION_NAME|* (  )
  {
  <SPLIT> return ;
  }   /* -----  end of function*|FUNCTION_NAME|* ----- */

The user can specify the function name which then will be applied twice. If
the macro was already in use the old value will be suggested as default.

MACRO MANIPULATION
------------------

A macro expansion can be controlled by the following attributes

  :l    change macro text to lowercase
  :u    change macro text to uppercase
  :c    capitalize macro text
  :L    legalize name

The include guard template is an example for the use of ':L' :

  == preprocessor.ifndef-def-endif ==
 #ifndef *|?BASENAME:L|_INC*
 #define *|BASENAME|_INC*
 <CURSOR><SPLIT>
 #endif   // ----- #ifndef*|BASENAME|_INC* -----

The base name of the file shall be used as part of the include guard name.
The predefined macro*|BASENAME|* is used to ask for this part because this
macro has already a defined value. That value can accepted or replaced by the
user. For the filename 'test test++test.h' the legalized base name
'TEST_TEST_TEST' will be suggested.

Legalization means:
 - replace all whitespaces by underscores
 - replace all non-word characters by underscores
 - replace '+' and '-' by underscore

5.3.4  The macros <+text+> etc.                      *csupport-templates-jump*

There are four macro types which can be used as jump targets in templates:

 <+text+>   Can be jumped to by hitting Ctrl-j.
 {+text+}   Same as <+text+>. Used in cases where indentation gives unwanted
            results with the first one.

 <-text->   Same as the two above. Will be removed if the template is used
 {-text-}   in visual mode.

The text inside the brackets is userdefined and can be empty. The text
can be composed from letters (uppercase and lowercase), digits, underscores
and blanks. After the insertion of an template these jump targets will be
highlighted.

5.3.5  Command Ctrl-j                                        *csupport-Ctrl-j*

Use the command Ctrl-j to jump to the next target. The target will be removed
and the mode will switched to insertion. Ctrl-j works in normal and in insert
mode.

The template for a function can be written as follows:

 == idioms.function ==
 void<CURSOR>
 |?FUNCTION_NAME| ( <+argument list+> )
 {
 <SPLIT>  return <+return value+>;
 }    /* -----  end of function |FUNCTION_NAME|  ----- */

The cursor will be set behind 'void'. You can remove 'void' easily with
Ctrl-w (delete word before cursor) and insert a new type. A Ctrl-j leads you
to the argument list. The target disappears and you can type on. When the
function body is written a final Ctrl-j brings you to the return statement.

The following example shows the usage of the type {-text-}. The idiom for the
opening of a file marks the line before the file is closed. This is also the
line where the template will be split to surround a marked area. In this case
(visual mode) the target is not needed and therefore removed (minus signs as
mnemonic). In normal and insert mode the target is meaningful and will be
therefore be present.  The form <-...-> would result in a wrong indentation of
the file close statement. The brace type will be handled as a block and the
indentation will be correct.

 == cpp.open-input-file ==
 char *ifs_file_name = "<CURSOR>";    /* input  file name       */
 ifstream ifs;              /* create ifstream object */

 ifs.open (ifs_file_name);    /* open ifstream          */
 if (!ifs) {
  cerr << "\nERROR : failed to open input  file " << ifs_file_name << endl;
  exit (EXIT_FAILURE);
 }
 <SPLIT>{-continue here-}
 ifs.close ();    /* close ifstream         */

Extra feature of Ctrl-j
-----------------------
If none of the above described targets is left Ctrl-j can be used to jump
behind closing brackets, parenthesis, braces,  or string terminators ('"`).
This feature is limited to the current line. Ctrl-j does not jump behind the
last character in a line.


How to switch the mapping for Ctrl-j off
----------------------------------------
The original meaning of Ctrl-j is 'move [n] lines downward' (see |CTRL-j|).
If you are accustomed to use the deafult and don't like these jump targets you
can switch them off.  Put the following line in the file .vimrc :

  let g:C_Ctrl_j   = 'off'

The default value of g:C_Ctrl_j is 'on'. You do not have to change the
template files. All jump targets will be removed before a template will be
inserted.

==============================================================================
5.4  SWITCHING BETWEEN TEMPLATE SETS                 *csupport-templates-sets*
==============================================================================

This plugin comes with two sets of templates. These are suggestions. You may
want to have additional sets for different projects or occasionally want to
use doxygen style comments.  To facilitate switching use the macro*|STYLE|*
(|csupport-templates-files|) to define a unique name and the
IF-ENDIF-construct to choose a particular set of files for example:

   ...

 *|STYLE|*    = C
  $
  $ =============================================================
  $ ========== FILE INCLUDES ====================================
  $ =============================================================
  $
  == IF *|STYLE|* IS C  ==
  $
  |includefile| = c.comments.template
  |includefile| = c.cpp.template
  |includefile| = c.idioms.template
  |includefile| = c.preprocessor.template
  |includefile| = c.statements.template
  $
  == ENDIF ==

   ...

The syntax is as follows:

  == IF macro_name IS macro_value  ==

  == ENDIF ==

Includes outside an IF-ENDIF construct are associated with the default style
'default'. A style set does not have to a complete set of templates. For an
incomplete set the other templates are taken from the default style.

IF, IS, and ENDIF are keywords.

HINT. Use these constructs to avoid overwriting your templates when updating
csupport. Copy and rename the set of files you want to change and surround the
includes with an appropriate IF-construct:

 *|STYLE|*    = MY_C
  $
   ...
  $
  == IF *|STYLE|* IS MY_C  ==
  |includefile| = my_c.comments.template
  |includefile| = my_c.cpp.template
  |includefile| = my_c.idioms.template
  |includefile| = my_c.preprocessor.template
  |includefile| = my_c.statements.template
  == ENDIF ==

Keep a copy of the main template file 'Templates' because this file will be
overwritten if you do not update manually.

==============================================================================
5.5  BINDING A STYLE TO A FILE EXTENSION             *csupport-templates-bind*
==============================================================================

You can bind the existing styles to one or more filename extensions. To do so
assign a Dictionary to the global variable g:C_Styles in '~/.vimrc' :

let g:C_Styles = { '*.c,*.h' : 'default', '*.cc,*.cpp,*.hh' : 'CPP' }

A Dictionary is created with a comma separated list of entries in curly
braces.  Each entry has a key and a value, separated by a colon.  Each key can
only appear once. The keys are themselves a comma separated list of filename
pattern. The values are existing styles defined in the template files.
The given style will be set automatically when switching to a buffer or
opening a new buffer with the associated filename pattern and supersedes the
macro *|STYLE|* .

==============================================================================
6.  C/C++ DICTIONARY                                     *csupport-dictionary*
==============================================================================

The files

 c-c++-keywords.list
 k+r.list
 stl_index.list

are a part of this plugin and can be used (together with your own lists) as
dictionaries for automatic word completion.  This feature is enabled by
default. The default word lists are

  plugin_dir/c-support/wordlists/c-c++-keywords.list
  plugin_dir/c-support/wordlists/k+r.list
  plugin_dir/c-support/wordlists/stl_index.list

The variable plugin_dir will automatically be set by the plugin to one of the
following values:
  $HOME.'/.vim/'        for Linux/Unix
  $VIM.'/vimfiles/'     for Windows
If you want to use an additional list MyC.list put the following lines into
 ~/.vimrc :

  let g:C_Dictionary_File = PLUGIN_DIR.'/c-support/wordlists/c-c++-keywords.list,'.
        \                   PLUGIN_DIR.'/c-support/wordlists/k+r.list,'.
        \                   PLUGIN_DIR.'/c-support/wordlists/stl_index.list,'.
        \                   PLUGIN_DIR.'/c-support/wordlists/MyC.list'

When in file ~/.vimrc the name PLUGIN_DIR has to be replaced by $HOME or
$VIM (see above). Whitespaces in the pathnames have to be escaped with a
backslash.
The right side is a comma separated list of files. Note the point at the end
of the first line (string concatenation) and the backslash in front of the
second line (continuation line).
You can use Vim's dictionary feature CTRL-X, CTRL-K (and CTRL-P, CTRL-N).

==============================================================================
7.  EXTENDING  ctags                                          *csupport-ctags*
==============================================================================

------------------------------------------------------------------------------
7.1  make AND qmake                                      *csupport-ctags-make*
------------------------------------------------------------------------------

The use of the Vim plugin taglist.vim (Author: Yegappan Lakshmanan) is highly
recommended. It uses the program ctags which generates tag files for 3 dozen
languages (Exuberant Ctags, Darren Hiebert, http://ctags.sourceforge.net).
With the following extensions the list of targets in a makefile can be shown
in the taglist window.

 1) Append the file customization.ctags to the file $HOME/.ctags .

 2) Add the following lines (from customization.vimrc) to $HOME/.vimrc :

  "
  "-------------------------------------------------------------------
  " taglist.vim : toggle the taglist window
  " taglist.vim : define the title texts for make
  " taglist.vim : define the title texts for qmake
  "-------------------------------------------------------------------
   noremap <silent> <F11>  <Esc><Esc>:Tlist<CR>
  inoremap <silent> <F11>  <Esc><Esc>:Tlist<CR>

  let tlist_make_settings  = 'make;m:makros;t:targets;i:includes'
  let tlist_qmake_settings = 'qmake;t:SystemVariables'

  if has("autocmd")
    " ----------  qmake : set file type for *.pro  ----------
    autocmd BufNewFile,BufRead *.pro  set filetype=qmake
  endif " has("autocmd")

 3) restart vim/gvim

The two maps will toggle the taglist window (hotkey F11) in all editing modes.
The two assignments define the headings for the (q)make sections in the
taglist window.  The autocmd set the file type 'qmake' for the filename
extension 'pro' (ctags needs this).

------------------------------------------------------------------------------
7.2  TEMPLATES                                      *csupport-ctags-templates*
------------------------------------------------------------------------------

If you frequently change the plugin  templates and you are using the taglist
plugin (section above) you may want to use this plugin for navigation. This is
achieved in two steps. First add a new language definition to  the file
$HOME/.ctags :

  --langdef=template
  --langmap=template:.template,TEMPLATE
  --regex-template=/^==\s+([^=]+)\s+==\s*(\s+==\s+([^=]+)\s+==)?/\1/t,template/

Now add the following lines to the file $HOME/.vimrc :

  let tlist_template_settings  = 'template;t:template'
  "---------------------------------------------------------------
  " plugin templates : set filetype for *.template
  "---------------------------------------------------------------
  if has("autocmd")
    autocmd BufNewFile,BufRead Templates  set filetype=template
    autocmd BufNewFile,BufRead *.template  set filetype=template
  endif " has("autocmd")

The assignment defines the heading for the template section in the taglist
window.  The autocmds set the file type 'template' for the main template file
'Templates' and the includefiles '*.template' (if any).

==============================================================================
8.  FOLDING                                                 *csupport-folding*
==============================================================================

This plugin can be used together with folding.

There are a few peculiarities when the cursor is on a closed fold before
inserting a template:

Normal mode
-----------
Inserting blocks of complete lines below and above a fold (e.g. frame
comments) and inserting at the top of a buffer (e.g. file description) works
as usual.
Insertions which go to the end of a line (e.g. end-of-line comments) and
insertions which go to the cursor position (e.g. 'sizeof()') will be suppressed
and a warning will be shown.

Visual mode
-----------
A range of lines containing closed folds can be surrounded by constructs which
have a visual mode, e.g. a for-loop:

    for ( ; ; ) {
  +---  4 lines: {------------------------------------------------------------
    }

See |folding| for more information on folding.

==============================================================================
9.  Additional Mappings                                 *csupport-ad-mappings*
==============================================================================

There are a few additional filetype specific key mappings defined in
'~/.vim/ftplugin/c.vim'.

Complete a classical C comment: '/*' => '/* | */' (modes: i,v).

Complete a classical C multi-line comment (mode: i):
  '/*<CR>' =>  /*
                * |
                */

Open a block (modes: i,v):
  '{<CR>' =>  {
                |
              }
In visual mode the content of the new block will be indented.

==============================================================================
10.  WINDOWS PARTICULARITIES                                *csupport-windows*
==============================================================================

For a user installation the plugin should go into the directory structure below
  $HOME/vimfiles/
for a system installation below
  $VIM/vimfiles/

The values of the two variables can be found from inside Vim:
   :echo $VIM
or
   :echo $HOME

The configuration files for a user are

  $HOME/_vimrc   and  $HOME/_gvimrc

for the system

  $VIM/_vimrc   and  $VIM/_gvimrc

Compiler settings:

It could be necessary to add further settings for your compiler.  To compile
C++-programs using a Dev-C++ installation (http://www.bloodshed.net) the
following item in $VIM/_vimrc is needed (depends on the Dev-C++ install
directory):

  let g:C_CFlags  = '-Wall -g -o0 -c -I c:\programs\dev-c++\include\g++'

==============================================================================
11.  ADDITIONAL TIPS                                           *csupport-tips*
==============================================================================

(1) gVim. Toggle 'insert mode' <--> 'normal mode' with the right mouse button
    (see mapping in file costumization.gvimrc).

(2) gVim. Use tear off menus.

(3) Try 'Focus under mouse' as window behavior (No mouse click when the mouse
    pointer is back from the menu item).

(4) Use Emulate3Buttons "on" (X11) even for a 3-button mouse. Pressing left
    and right button at the same time without moving your fingers is faster
    then moving a finger to the middle button (often a wheel).

==============================================================================
12.  TROUBLESHOOTING                                *csupport-troubleshooting*
==============================================================================

* I do not see any new main menu item.
  - Was the archive extracted into the right directory?

* How can I see what was loaded?
  - Use ':scriptnames' from the Vim command line.

* No main menu item.
  - Loading of plugin files must be enabled. If not use
      :filetype plugin on
    This is the minimal content of the file '$HOME/.vimrc'. Create one if there
    is none, or better use customization.vimrc.

* Most key mappings do not work.
  - They are defined in a filetype plugin in '$HOME/.vim/ftplugin/'. Use
    ':filetype' to check if filetype plugins are enabled. If not, add the line
      filetype plugin on
    to the file '~/.vimrc'.

* Some hotkeys do not work.
  - The hotkeys might be in use by your graphical desktop environment.  Under
    KDE Ctrl-F9 is the hotkey which let you switch to the 9. desktop.  The key
    settings can usually be redefined.

* Splint and/or CodeCheck menu item not visible.
  - The program is not installed or not found (path not set) or not executable.

==============================================================================
13.  RELEASE NOTES                                    *csupport-release-notes*
==============================================================================
See file c-support/doc/ChangeLog .

==============================================================================
vim:tw=78:noet:ts=2:ft=help:norl:
