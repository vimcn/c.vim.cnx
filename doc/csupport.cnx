*csupport.txt*                  C/C++ Support                    2011-06-26

C/C++ Support                                           *c-support* *csupport*
                              插件版本 5.14
                    针对 Vim version 7.0 及其以上版本
                  作者：Fritz Mehner  <mehner@fh-swf.de>
              译者：Tiger Lee     <i.m.tiger.lee[AT]gmail.com>

Vim/gVim的C/C++-IDE。开发它是为了极为迅速地以一致的风格来编写代码。这是通过
插入整句，惯用法，代码片断，模板和注释来完成的。并可使用一键来完成语法检查，
编译，运行程序，运行代码检查工具或重新格式化代码。

 1.    在GUI下使用                              |csupport-usage-gvim|
 1.1    'Comments'菜单                          |csupport-comm|
 1.1.1   追加已对齐注释                         |csupport-comm-aligned|
 1.1.2   调整行尾注释                           |csupport-comm-realign|
 1.1.3   代码转注释                             |csupport-code-to-comm|
 1.1.4   注释转代码                             |csupport-comm-to-code|
 1.1.5   框注释，文件头，...                    |csupport-comm-frame|
 1.1.6   文件区块注释...                        |csupport-comm-sections|
 1.1.7   关键字注释，特殊注释                   |csupport-comm-keyword|
 1.1.8   标记(插件)                             |csupport-comm-tags|
 1.1.9   日期和日期+时间                        |csupport-comm-date|
 1.1.10  C to C++ comments and vice versa       |csupport-comm-c-cpp|
 1.2    'Statements'菜单                        |csupport-stat|
 1.2.1   正常模式，插入模式                     |csupport-stat-normal-mode|
 1.2.2   可视模式                               |csupport-stat-visual-mode|
 1.3    'Preprocessor'菜单                      |csupport-prep|
 1.3.1   正常模式，插入模式                     |csupport-prep-normal-mode|
 1.3.2   可视模式                               |csupport-prep-visual-mode|
 1.3.3   Block out code with #if 0 .. #endif    |csupport-prep-if0|
 1.3.4   Ex-commands                            |csupport-prep-ex|
 1.4    Menu 'Idioms'                           |csupport-idioms|
 1.4.1   Item 'function'                        |csupport-idioms-function|
 1.4.2   for-loop control                       |csupport-idioms-for-loop|
 1.4.3   Item 'open input file'                 |csupport-idioms-input|
 1.4.4   Item 'open output file'                |csupport-idioms-output|
 1.5    Menu 'Snippets'                         |csupport-snippets|
 1.5.1   Code snippets                          |csupport-snippets|
 1.5.2   Picking up prototypes                  |csupport-proto|
 1.5.3   Code templates                         |csupport-templates-menu|
 1.6    Menu 'C++'                              |csupport-c++|
 1.6.1   Normal mode, insert mode.              |csupport-c++-normal-mode|
 1.6.2   Visual mode.                           |csupport-c++-visual-mode|
 1.6.3   Method implementation                  |csupport-c++-method-impl|
 1.6.4  Ex commands                             |csupport-c++-ex|
 1.7    Menu 'Run'                              |csupport-run|
 1.7.1   Minimal make functionality             |csupport-run-buffer|
 1.7.2   Command line arguments                 |csupport-run-cmdline-args|
 1.7.3   Run make                               |csupport-run-make|
 1.7.4   Executable to run                      |csupport-run-make-run|
 1.7.5   Run make clean                         |csupport-run-make-clean|
 1.7.6   Command line arguments for make        |csupport-run-make-args|
 1.7.7   Splint                                 |csupport-run-splint|
 1.7.8   CodeCheck                              |csupport-run-codecheck|
 1.7.9   Indent                                 |csupport-run-indent|
 1.7.10  Hardcopy                               |csupport-run-hardcopy|
 1.7.11  Rebuild templates                      |csupport-run-templates|
 1.7.12  Xterm size                             |csupport-run-xterm|
 1.7.13  Output redirection                     |csupport-run-output|
 1.8    Help                                    |csupport-help|
 
 2.    Usage without GUI                        |csupport-usage-vim|
 3.    Hotkeys                                  |csupport-hotkeys|
 4.    Customization and configuration          |csupport-custom|
 4.1    Global variables                        |csupport-custom-glob-vars|
 4.2     The root menu                          |csupport-custom-root|
 4.3     System-wide installation               |csupport-system-wide|
 5.    Template files and tags                  |csupport-templates|
 5.1    Template files                          |csupport-templates-files|
 5.2    Macros                                  |csupport-templates-macros|
 5.2.1  User defined formats for date and time  |csupport-templates-date|
 5.3    Templates                               |csupport-templates-names|
 5.3.1  Template names                          |csupport-templates-names|
 5.3.2  Template definition                     |csupport-templates-definition|
 5.3.3  Template expansion                      |csupport-templates-expansion|
 5.3.4  The macros <+text+> etc.                |csupport-templates-jump|
 5.3.5  Command Ctrl-j                          |csupport-Ctrl-j|
 5.4    Switching between template sets         |csupport-templates-sets|
 5.5    Binding a style to a file extension     |csupport-templates-bind|
 6.    C/C++ Dictionaries                       |csupport-dictionary|
 7.    Extend ctags                             |csupport-ctags|
 7.1   Make and qmake                           |csupport-ctags-make|
 7.2   Templates                                |csupport-ctags-templates|
 8.    Folding                                  |csupport-folding|
 9     Additional Mappings                      |csupport-ad-mappings|
 10.   Windows particularities                  |csupport-windows|
 11.   Additional tips                          |csupport-tips|
 12.   Troubleshooting                          |csupport-troubleshooting|
 13.   Release Notes /Change Log                |csupport-release-notes|

       How to add this help file to Vim's help  |add-local-help|


==============================================================================
1.  在GUI下使用  (gVim)                                  *csupport-usage-gvim*
==============================================================================

如果看不见根菜单'C/C++'，则可从根菜单'Tools' 的子项"Load C Support"启用它。
菜单项"Load C Support"同样也可用于卸载根目录'C/C++'。

几乎所有的菜单项都会插入代码片断或注释。所有这些都包含在模板文件中，并且可以由
用户修改以达到他们的需求(参见|csupport-templates|)。

------------------------------------------------------------------------------
1.1 'Comments' 目录                                            *csupport-comm*
------------------------------------------------------------------------------

1.1.1  在连续行中追加已对齐的注释                      *csupport-comm-aligned*

在正常模式，菜单项"end-of-line comment"将会在当前行追加一条注释。
在可视模式，这个选项将会在所有已标记的行追加已对齐的注释。标记前面4行。

  print_double_array ( double array[],
                       int    n,
                       int    columns,
                       char*  arrayname
                       )

并且选中'end-of-line com'，将会产生'/*  */'。

  print_double_array ( double array[],          /*  */
                       int    n,                /*  */
                       int    columns,          /*  */
                       char*  arrayname         /*  */
                       )

如果有一行或多行超过起始列，注释将会在最长那行之后的第二列开始。光标将会放置
在第一条注释里。

默认的起始列是 49 ( = (2，4或8的倍数) + 1 )。这个值可以在文件 ~/.vimrc 中
设定一个全局变量来改变，例如：

  let g:C_LineEndCommColDefault    = 45

起始列也可以由菜单项'Comments->set end-of-line com. col'设定。只需将光标放置于
任意列(列数显示在Vim的状态栏)并且选择这个菜单项。这个设定与缓冲区有关。

如果光标位于行尾，你将会被询问一个列数，因为这个位置极有可能不是想要的起始列。
你的选择会被确认。

------------------------------------------------------------------------------

1.1.2  调整行尾注释                                   *csupport-comm-realign*

在一些改动后，行尾注释可能不再整齐了：

  print_double_array ( double       array[],          /*  */
                       long int     n,                     /*  */
                       unsigned int columns,          /*  */
                       char*        a_name         /*  */
                       )                        /*  */

使用菜单项'adjust end-of-line com.'可以实现重新对齐。 在正常模式下，当前行的注释
(如果有的话)会尽可能的与行尾注释列(如下)对齐。在可视模式下，标记的块将会被对齐：

  print_double_array ( double       array[],    /*  */
                       long int     n,          /*  */
                       unsigned int columns,    /*  */
                       char*        a_name      /*  */
                       )                        /*  */

只有前导空格的注释不会重新对齐，它们通常都是标题：

  max = other.max;                    /* the maximum value */
  len = other.len;                         /* the length        */
  /* ===== the next section ===== */
  pos = (x+y+z)/3.0;             /* the next position */

在对齐之后：

  max = other.max;                              /* the maximum value */
  len = other.len;                              /* the length        */
  /* ===== the next section ===== */
  pos = (x+y+z)/3.0;                            /* the next position */

------------------------------------------------------------------------------

1.1.3  代码转注释                                      *csupport-code-to-comm*

标记块

xxxxxxxx
xxxxxxxx
xxxxxxxx

将会由菜单项'code->comment /**/'变成多行注释 (全部或部分标记的行)：

/* xxxxxxxx
 * xxxxxxxx
 * xxxxxxxx
 */

标记块将会由菜单项'code->comment //'变成多行注释：

//xxxxxxxx
//xxxxxxxx
//xxxxxxxx

这两个菜单项也作用于单行，但没必要先标记单行。

------------------------------------------------------------------------------

1.1.4  注释转代码                                      *csupport-comm-to-code*

如果标记了一行(或多行)完整的注释(比如：所有的行都属于注释)，菜单项
"comment->code"将会取消注释，如果标记了以下行：

   * printf ("\n");
   */

  printf ("\n");

  //  printf ("\n");
  //

  /*
   *  printf ("\n");
   */

取消注释将会变成

   * printf ("\n");
   */

  printf ("\n");

  printf ("\n");



  printf ("\n");

前两行仅仅是C注释的一部分，所以保持不变。一条C注释的开始可以是/*，/**或者/*!。

这个菜单项也作用于前导为//的单行，但没必要先标记单行。

------------------------------------------------------------------------------

1.1.5  框注释，文件头，...                               *csupport-comm-frame*

框注释、文件头注释、函数注释、方法注释和类描述注释都是从对应的文件中做为模板
读取的。(参见 |csupport-templates|).

一共有两种类型的文件描述模板 (菜单项"file description (impl.)"和
"file description (header)", 同样参见 |csupport-templates|)：

  comment.file-description         : 所有 *.c, *.cc, *.cp, *.cxx, *.cpp, *.CPP,
                                      *.c++, *.C, *.i, *.ii 

  comment.file-description-header  : 所有文件类型为'c'或'cpp'

同样，适当的模板将会被包含进一个新文件。这由插件根据文件扩展名来决定。 默认
显示上述模板。你可以在'~/.vimrc'中设置一个全局变量来改变这个扩展名列表。

  au BufRead,BufNewFile  *.XYZ  set filetype=c

  let g:C_SourceCodeExtensions  = 'XYZ c cc cp cxx cpp CPP c++ C i ii'

新文件'test.XYZ'将会被认为是一个C的实现文件。

------------------------------------------------------------------------------

1.1.6  文件区块注释                                   *csupport-comm-sections*

文件区块注释可以用相似风格的注释来分隔典型的C和H文件区块，例如：

/* #####   HEADER FILE INCLUDES   ################################################### */

/* #####   MACROS  -  LOCAL TO THIS SOURCE FILE   ################################### */

/* #####   TYPE DEFINITIONS  -  LOCAL TO THIS SOURCE FILE   ######################### */

在C/C++文件中，也可以使用快捷键 \ccs 来插入这些区块注释，或是在头文件中使用 \chs。
这些快捷键会在命令栏执行'CFileSection'或'HFileSection'：

 :CFileSection 
 :HFileSection 

现在，按下<Tab>键显示选项菜单，并从中挑一个吧。

------------------------------------------------------------------------------

1.1.7  关键字注释，特殊注释                            *csupport-comm-keyword*

关键字注释是行尾注释：

 /* :<关键字>:<date+time>:<author reference>: <arbitrary comment text> */

关键字包括：

 BUG COMPILER TODO TRICKY WARNING WORKAROUND 用户自定义关键字

这些预备注释是用于标注快速恢复工作的位置。它们通常意味着不是为了最终文档。这些
注释可以很容易地通过关键字搜索到。
关键字注释也可以使用快捷键\ckc。这个快捷键会在命令栏运行命令"KeywordComment"：

 :KeywordComment

现在按下<Tab>调出选择菜单来挑一个。

特别注释偶尔用于在一段代码构成中注明特别的特性(例如：在一个switch语句中失败的情况，
一个空循环)：

 /* EMPTY */
 /* NOT REACHED */
 /* REMAINS TO BE IMPLEMENTED */
  ....

特殊注释也可以使用快捷键\csc。这个快捷键会在命令栏运行命令"KeywordComment"：

 :SpecialComment

现在按下<Tab>调出选择菜单来挑一个。

------------------------------------------------------------------------------

1.1.8  标签 (插件)                                        *csupport-comm-tags*

'tags (plugin)'子菜单可以让你从模板系统(see|csupport-templates-macros|)插入
预定义的宏 template system (参见|csupport-templates-macros|). 在可视模式下，
宏会替换被标记的文本。

------------------------------------------------------------------------------

1.1.9  日期和日期+时间                                    *csupport-comm-date*

'date'和'date time'可以由用户来定义(参见|csupport-templates-date|)。在可视
模式下，宏会替换被标记的文本。(例如：更新日期和时间)。

------------------------------------------------------------------------------

1.1.10 C注释转C++注释， AND VICE VERSA                  *csupport-comm-c-cpp*

菜单项"// xxx -> /* xxx */"将C++注释转换成C注释。这可以在正常模式或插入模式的
当前行和可视模式的标记块中完成。
如果有多个C注释，则只有第一个会被转换：
  printf ("\n");                     /* one */ /* two */ /* three */
会变成
  printf ("\n");                     // one  /* two */ /* three */

菜单项"/* xxx */ -> // xxx"将C注释转换成C++注释。

------------------------------------------------------------------------------
1.2  'Statements'菜单                                          *csupport-stat*
------------------------------------------------------------------------------

1.2.1  正常模式，插入模式                          *csupport-stat-normal-mode*

将会插入一条空语句并适当缩进。菜单项"if{}"将会插入一条if语句：

if (  )
{
}


1.2.2  可视模式                                    *csupport-stat-visual-mode*

带代码块的语句和case标签
--------------------------------------
高亮区域

xxxxx
xxxxx

将会被以下语句之一环绕：

  +----------------------------+-----------------------------+
  |     if (  )                |     if (  )                 |
  |     {                      |     {                       |
  |       xxxxx                |       xxxxx                 |
  |       xxxxx                |       xxxxx                 |
  |     }                      |     }                       |
  |                            |     else                    |
  |                            |     {                       |
  |                            |     }                       |
  +----------------------------+-----------------------------+
  |     for ( ; ;  )           |     while (  )              |
  |     {                      |     {                       |
  |       xxxxx                |       xxxxx                 |
  |       xxxxx                |       xxxxx                 |
  |     }                      |     }                       |
  +----------------------------+-----------------------------+
  |     do                     |                             |
  |     {                      |     {                       |
  |       xxxxx                |       xxxxx                 |
  |       xxxxx                |       xxxxx                 |
  |     }                      |     }                       |
  |     while (  );            |                             |
  +----------------------------+-----------------------------+
  |      switch (  ) {                                       |
  |      case :                                              |
  |       break;                                             |
  |                                                          |
  |      case :                                              |
  |       break;                                             |
  |                                                          |
  |      case :                                              |
  |       break;                                             |
  |                                                          |
  |      case :                                              |
  |       break;                                             |
  |                                                          |
  |      default:                                            |
  |       break;                                             |
  |      }                                                   |
  +----------------------------+-----------------------------+

整个语句在插入后会进行缩进。


不带代码块的语句
--------------------------
将会插入以下语句之一

  +-------------------------------+--------------------------+
  |    if (  )                    |    for ( ; ;  )          |
  +-------------------------------+--------------------------+
  |    if (  )                    |    while (  )            |
  |    else                       |                          |
  +-------------------------------+--------------------------+
  |    case :                     |                          |
  |      break;                   |                          |
  +-------------------------------+--------------------------+


------------------------------------------------------------------------------
1.3  'Preprocessor'菜单                                        *csupport-prep*
------------------------------------------------------------------------------

1.3.1  正常模式，插入模式                          *csupport-prep-normal-mode*

将会插入预处理器语句并适当缩进。

1.3.2  可视模式                                    *csupport-prep-visual-mode*

带代码块的语句
----------------------
高亮区域

xxxxx
xxxxx

将会被以下语句之一环绕：

  +----------------------------+-----------------------------+
  |    #if  CONDITION                                        |
  |    xxxxx                                                 |
  |    xxxxx                                                 |
  |    #else      /* ----- #if CONDITION  ----- */           |
  |                                                          |
  |    #endif     /* ----- #if CONDITION  ----- */           |
  +----------------------------------------------------------+
  |    #ifdef  CONDITION                                     |
  |    xxxxx                                                 |
  |    xxxxx                                                 |
  |    #else      /* ----- #ifdef CONDITION  ----- */        |
  |                                                          |
  |    #endif     /* ----- #ifdef CONDITION  ----- */        |
  +----------------------------------------------------------+
  |    #ifndef  CONDITION                                    |
  |    xxxxx                                                 |
  |    xxxxx                                                 |
  |    #else      /* ----- #ifndef CONDITION  ----- */       |
  |                                                          |
  |    #endif     /* ----- #ifndef CONDITION  ----- */       |
  +----------------------------------------------------------+
  |    #ifndef  INC_TEST                                     |
  |    #define  INC_TEST                                     |
  |    xxxxx                                                 |
  |    xxxxx                                                 |
  |    #endif   /* ----- #ifndef INC_TEST  ----- */          |
  +----------------------------------------------------------+
  |    #if  0     /* ----- #if 0 : If0Label_1 ----- */       |
  |                                                          |
  |    #endif     /* ----- #if 0 : If0Label_1 ----- */       |
  +----------------------------------------------------------+

作为一个建议，包含防护的宏名字(如上INC_TEST)将由文件名得来。

1.3.3  用"#if 0 ... #endif"封闭代码                        *csupport-prep-if0*

菜单项"#if 0 #endif"插入行

  #if  0     /* ----- #if 0 : If0Label_1 ----- */

  #endif     /* ----- #if 0 : If0Label_1 ----- */

在可视模式下，标记的代码块会被这些行包围。

这通常用来暂时封闭一些代码。像标签名If0Label_1是自动插入到代码中的。尾部的数字
是自动递增的。用户可以修改这些数字。下一个数字将会比当前缓冲区中最大的数字还要
大一。

对应的标签可以使用vim的星号命令(*)来搜索到。所有的标签都可以使用全局搜索，像
:g/If0Label_/或:g/If0Label_\d\+/。所有对应的行都可以使用:g/If0Label_/d删除。


去除包围结构"#if 0 ... #endif"

如果光标位于这样的段落中间或者在邻近的两行之上，菜单项'remove #if #endif'将
会删除这个结构。原生的结构不会受到影响。

1.3.4  额外命令                                          *csupport-prep-ex*

有4个附加的额外命令可以用来插入包含语句:

 额外命令               快捷键     包含
 -------------------------------------------------------------------------
 :IncludeStdLibrary     \ps        C 标准库
 :IncludeC99Library     \pc        C99 库
 :IncludeCppLibrary     \+ps       C++ 标准库
 :IncludeCppCLibrary    \+pc       C 标准库 ( #include <c...> )

Type :Inc<Tab> and choose one of the commands. Now type an additional space
and a <Tab> to show the whole list list or type a space and a few leading
characters to reduce this list.

------------------------------------------------------------------------------
1.4  MENU 'Idioms'                                           *csupport-idioms*
------------------------------------------------------------------------------

1.4.1  Item 'function'                              *csupport-idioms-function*

NORMAL MODE, INSERT MODE:
The name of the function is asked for and the following lines (for function
name "f") will be inserted:

  void
  f (  )
  {
    return ;
  }        /* ----------  end of function f  ---------- */

VISUAL MODE:
Main or [static] function: the highlighted lines will go inside the new
function or main.
for-loops: the highlighted lines will be set in braces.

1.4.2  for-loop control                             *csupport-idioms-for-loop*

The menu items 'for( x=0; ... )' and 'for( x=n-1; ... )' can be used to write
the control statement for a for-loop counting upward or downward. These items
start an input dialog

 [TYPE (expand)] VARIABLE [START [END [INCR.]]] :

asking for at least the name of the loop variable. The other parameters are
optional. The type is restricted to the following integral data types:

  char
  int
  long
  long int
  long long
  long long int
  short
  short int
  size_t
  unsigned 
  unsigned char
  unsigned int
  unsigned long
  unsigned long int
  unsigned long long
  unsigned long long int
  unsigned short
  unsigned short int

One of these types can be specified by typing it completely or by typing zero
or more characters of its name and completing them to the full name by using
the tab key (tab completion). If the start of the type name is ambiguous (e.g.
'uns') a list of completion candidates is provided to choose from.

1.4.3  Item 'open input file'                          *csupport-idioms-input*

The item 'open input file' will create the statements to open and close an
input file (e.g. with the file pointer 'infile').

1.4.4  Item 'open output file'                        *csupport-idioms-output*

The item 'open output file' will create the statements to open and close an
output file (e.g. with the file pointer 'outfile').

------------------------------------------------------------------------------
1.5  MENU 'Snippets'                                       *csupport-snippets*
------------------------------------------------------------------------------

1.5.1  CODE SNIPPETS

Code snippets are pieces of code which are kept in separate files in a special
directory (e.g. a few lines of code or a complete template for a Makefile).
File names are used to identify the snippets.  The snippet directory will be
created during the installation  ( $HOME/.vim/codesnippets-c is the default).
Snippets are managed with the 3 items

   C/C++ -> Snippets -> read  code snippet
   C/C++ -> Snippets -> write code snippet
   C/C++ -> Snippets -> edit  code snippet

from the Snippets submenu.

CREATING A NEW SNIPPET
When nothing is marked, "write code snippet" will write the whole buffer
to a snippet file, otherwise the marked area will be written to a file.

INSERT A SNIPPET
Select the appropriate file from the snippet directory ("read  code snippet").
The inserted lines will be indented.

EDIT A SNIPPET
This is a normal edit.

INDENTATION / NO INDENTATION
Code snippets are normally indented after insertion. To suppress indentation
add the file extension "ni" or "noindent" to the snippet file name, e.g.

  parameter_handling.c.noindent

Snippet browser
---------------
Under a GUI a file requester will be put up. Without GUI the filename will be
read from the command line. You can change this behavior by setting a global
variable in your ~/.vimrc :

 let g:C_GuiSnippetBrowser = 'commandline'

The default value is 'gui'. 


1.5.2   PICKING UP PROTOTYPES                                 *csupport-proto*

PICK UP PROTOTYPES.
To make a prototype from a function head mark the function head and choose
'Snippets -> pick up prototype'. From the first six lines of

   void
  print_double_array (  double array[],  /* array to print                */
                        int    n,        /* number of elements to print   */
                        int    columns,  /* number of elements per column */
                        char*  arrayname /* array name                    */
                        )
  {
    ...
  }       /* ----------  end of function print_double_array  ---------- */

the prototype

  void print_double_array ( double array[], int n, int columns, char* arrayname );

is produced and put in an internal buffer.
- Leading and trailing whitespaces are removed.
- All inner whitespaces are squeezed.
- All comments will be discarded.
- Trailing parts of the function body (e.g a '{' ) will also be removed.
- The class name and the scope resolution operator will be removed (C++ method
  implementations).
Further prototypes can be picked up and gathered in the buffer.

For C++ methods namespace names and class names will be removed
(exception: 'std::' ). The first two lines of

  std::string
  ROBOT::Robot::get_name  ( void )
  {
    return type_name;
  }   /* -----  end of method Robot::get_name  ----- */

result in the prototype

  std::string get_name ( void );

Folding may help picking up prototypes (see |csupport-folding|).


INSERT PROTOTYPES
With 'Snippets -> insert prototype(s)' all picked up prototypes currently in
the buffer will be inserted below the cursor.
The prototype buffer will be cleared after insertion.


DISCARD PROTOTYPES
The prototype buffer can be cleared with 'Snippets -> clear prototype(s)' .


SHOW PROTOTYPES
The list of gathered prototypes can be shown with
'Snippets -> show prototype(s)'. The number and the filename are shown, e.g.

  (1) matrix.c #  double** calloc_double_matrix ( int rows, int columns );
  (2) matrix.c #  void free_double_matrix ( double **m );
  (3) foomain.c #  void foo ( );


REMARK. Generating prototypes this way is nice in a small project. You may
want to use an extractor like cextract or something else.


1.5.3  Code Templates                                *csupport-templates-menu*
---------------------
Nearly all menu entries insert code snippets or comments. All these stuff is
taken from template files and can be changed by the user to meet his
requirements (see|csupport-templates|on how to use the template system).

The menu item 'edit local templates' opens the main template file in a local
plugin installation. This is usually the file
'~/.vim/c-support/templates/Templates'.  There may be dependent files
loaded from the main file.  Now change whatever file you want, save it, and
click on the menu item 'reread templates' to read in the file(s) and to
rebuild the internal representation of the templates.

The menu item 'edit global templates' opens the main template file in a
system-wide plugin installation (see |csupport-system-wide|). This is
usually the file '$VIM./vimfiles/c-support/templates/Templates'.

Template browser
----------------
Under a GUI a file requester will be put up. Without GUI the filename will be
read from the command line. You can change this behavior by setting a global
variable in your ~/.vimrc :

 let g:C_GuiTemplateBrowser = 'explorer'

The default value is 'gui'. 'explorer' will start the file explorer
(see help|:Explore|). To use the commandline asign 'commandline'.

------------------------------------------------------------------------------
1.6  MENU 'C++'                                                 *csupport-c++*
------------------------------------------------------------------------------

1.6.1  NORMAL MODE, INSERT MODE.                    *csupport-c++-normal-mode*

An empty statement will be inserted and in some cases properly indented. The
item 'try .. catch' will insert the following lines:

  try {
  }
  catch ( const &ExceptObj ) {    // handle exception:
  }
  catch (...) {   // handle exception: unspecified
  }

The cursor will go into the try block.

1.6.2  VISUAL MODE.                                 *csupport-c++-visual-mode*

The highlighted area can be surrounded by one of the following statements:

  try - catch
  catch
  catch(...)
  namespace { }
  extern "C" { }

The whole statement will be indented after insertion.

1.6.3   METHOD IMPLEMENTATION                       *csupport-c++-method-impl*

The menu item 'method implement.' asks for a method name. If this item is
called the first time you will see just an scope resolution operator.  If you
specify the scope this is used the next time you call this item.  If you use
one of the menu items to generate a class (see |csupport-templates|) the
scope will be extracted and used for the next method.

1.6.4  EX COMMANDS                                           *csupport-c++-ex*

There are 4 additional Ex command which can be used to insert include
statements. Please see |csupport-prep-ex|.

------------------------------------------------------------------------------
1.7  MENU 'Run'                                                 *csupport-run*
------------------------------------------------------------------------------

1.7.1  MINIMAL MAKE FUNCTIONALITY                        *csupport-run-buffer*

The 'Run' menu provides a minimal make functionality for single file projects
(e.g. in education) :

SAVE AND COMPILE
'save and compile' saves the buffer and run the compiler with the given
options (see |csupport-custom-glob-vars|).

An error window will be opened if the compiler reports errors and/or warnings.
Quickfix commands can now be used to jump to an error location.

Consider using maps like
  map  <silent> <F7>    <Esc>:cprevious<CR>
  map  <silent> <F8>    <Esc>:cnext<CR>
in your ~/.vimrc file to jump over the error locations and make navigation
easier.  The error list and the error locations in your source buffer will be
synchronized.

The filename extension for an object file can be set in ~.vimrc :

  let g:C_ObjExtension = '.obj'

The default is '.o' ('.obj' for Windows).

LINK
'link' makes an executable from the current buffer. If the buffer is not
saved, or no object is available or the object is older then the source step
'save and compile' is executed first.
The linkging will only be tried if the current buffer contains a main
function.

The behavior of the compiler / linker is determined by the options assigned to
the variables described in |csupport-custom-glob-vars| (4.group).

RUN
'run' runs the executable with the same name  as the current buffer. If the
buffer is not saved, or no executable is available or the executable is older
then the source steps 'save and compile' and 'link' are executed first.

The filename extension for an executable can be set in ~.vimrc :

  let g:C_ExeExtension = '.exe'

The default is the empty string.

1.7.2  COMMAND LINE ARGUMENTS                      *csupport-run-cmdline-args*

The item 'command line arguments' calls an input dialog which asks for command
line arguments. These arguments are forwarded to the program which is run by
the 'run' item. The arguments are kept until you change them.
For the first and only the first argument file name expansion will work (use
the Tab-key). Only the first string of the input can be expanded due to a
restriction of the Vim input function. To expand two or more filenames
specify them in reverse order: type the first characters of the last filename
and expand them. Go to the start of the input and type the beginning of the
last but one filename and expand it.

The arguments belong to the current buffer (that is, each buffer can have its
own arguments).
If the buffer gets a new name with "save as" the arguments will now belong to
the buffer with the new name.

The command line arguments can be followed by pipes and redirections:

  11 22 | sort -rn | head -10 > out

Caveat: If you look for the current arguments by calling this menu item again
be sure to leave it with a CR (not Esc !). Due to a limitation of an internal
Vim function CR will keep the arguments, Esc will discard them.


1.7.3  RUN make                                            *csupport-run-make*

The item 'make' runs the external make program.  An error window will be
opened if the compiler or linker reports errors or warnings during the make
process.  Quickfix commands can now be used to jump to an error location.

When inside a makefile the hotkeys \rm, \rmc , and \rma are working (see
|csupport-usage-vim|).
The snippets collection contains a sample makefile which can easily adepted
for small projcts.

1.7.4  EXECUTABLE TO RUN                               *csupport-run-make-run*

The item 'executable to run' asks for the name of the executable built by
make.  If the name given is nonempty this executable will be run by the menu
item 'run' (\rr, C-F9).
To return to the default behavior (see |csupport-run-buffer|) remove the name
with the another 'executable to run'.

1.7.5  RUN make clean                                *csupport-run-make-clean*

The item 'make' runs the external make program with the standard target 'clean'.


1.7.6  COMMAND LINE ARGUMENTS FOR make                *csupport-run-make-args*

The item 'command line arguments for make' calls an input dialog which asks
for command line arguments for make. These arguments are forwarded to make
when called by the menu item 'make'.
For the first and only the first argument the file name expansion will work
(use the Tab-key).


1.7.7  SPLINT                                            *csupport-run-splint*

Splint is a tool for statically checking C programs (see http://www.splint.org).
Of course it has to be installed in order to be used within Vim.  The menu
item 'Run->splint' will run the current buffer through splint.

An error window will be opened if splint has something to complain about.
Quickfix commands can now be used to jump to an error location.  For easier
navigation see tip under 'SAVE AND COMPILE' |csupport-run-buffer|.

Splint has many options. Presumably the best way is to keep the options in an
option file (~/.splintrc). For a quick try you can use the menu item
'Run->cmd. line arg. for splint' to specify some buffer related options.

When vim is started this plugin will check whether splint is executable. If
not, the menu item will *NOT' be visible.


1.7.8  CODECHECK                                      *csupport-run-codecheck*

CodeCheck (TM) is a commercial code analyzing tool produced by Abraxas
Software, Inc.  (www.abraxas-software.com).
Of course it has to be installed in order to be used within Vim.  The menu
item 'Run->CodeCheck' will run the current buffer through CodeCheck.

An error window will be opened if CodeCheck has something to complain about.
Quickfix commands can now be used to jump to an error location.  For easier
navigation see tip under 'SAVE AND COMPILE' |csupport-run-buffer|.

CodeCheck has many options.  For a quick try you can use the menu item
'Run->cmd. line arg. for CodeCheck' to specify some buffer related options.

CodeCheck will be run with default options (see |csupport-custom-glob-vars|).
The default options can be overwritten by  placing a global variable in
~/.vimrc , e.g.

  let  g:C_CodeCheckOptions = "-K13 -Rmeyers"

The default name for the executable is 'check'.  There are other names in use
on different platforms.  The name can be changed by placing a global variable
in ~/.vimrc , e.g.

  let  g:C_CodeCheckExeName = "chknt.exe"

When vim is started this plugin will check whether CodeCheck is executable. If
not, the menu item will *NOT' be visible.


1.7.9  INDENT                                            *csupport-run-indent*

The formatter 'indent' can be run over the whole buffer.  Before formatting a
buffer this buffer will be saved to disk and you will be asked for a
confirmation.

Indent has many options. These are kept in the file '.indent.pro' in your home
directory. See the indent manual for more information.


1.7.10  HARDCOPY                                       *csupport-run-hardcopy*

Generates a PostScript file from the whole buffer or from a marked region.
On a Windows system a printer dialog is displayed.
The hardcopy goes to the current working directory.  If the buffer contains
documentation or other material from non-writable directories the hardcopy
goes to the HOME directory. The output destination will be shown in a message.

The print header contains date and time for the current locale. The definition
used is

  let s:C_Printheader = "%<%f%h%m%<  %=%{strftime('%x %X')}     Page %N"

The current locale can be overwritten by changing the language, e.g.

  :language C

or by setting a global variable in the file ~/.vimrc , e.g. :

  let g:C_Printheader = "%<%f%h%m%<  %=%{strftime('%x %X')}     SEITE %N"

See :h printheader and :h strftime()  for more details.


1.7.11  REBUILD TEMPLATES                             *csupport-run-templates*

After editing one or more template files  a click on this item rereads the
template files and rebuilds all templates.


1.7.12  XTERM SIZE                                        *csupport-run-xterm*

The size of the xterm used for  running a program (below) can be set by this
menu item. The default is 80 columns with 24 lines.
This feature is not available under Windows.


1.7.13  OUTPUT REDIRECTION                               *csupport-run-output*

Running a program can be done in one of three ways:
(1) Run the program from the gVim command line.
    This is for interactive programs with little input and output.
(2) Run the program and direct the output into a window with name "C-Output".
    The buffer and its content will disappear when the window is closed and
    reused otherwise.
    This is for non-interactive programs with little to very much output.
    You have unlimited line length, regex search, navigation, ...
    The tabstop value will be set to 8  for "C-Output".
(3) Run the program in an xterm.

The output method can be chosen from the menu item 'Run->output: ...'.
This menu has three states:

  output: VIM->buffer->xterm
  output: BUFFER->xterm->vim
  output: XTERM->vim->buffer

The first (uppercase) item shows the current method.  The default is 'vim'.
This can be changed by setting the variable g:C_OutputGvim to another value.
Possible values are 'vim', 'buffer' and 'xterm' .

The xterm defaults can be set in ~/.vimrc by the variable g:C_XtermDefaults .
The default is "-fa courier -fs 12 -geometry 80x24" :
  font name     : -fa courier
  font size     : -fs 12
  terminal size : -geometry 80x24
See 'xterm -help' for more options. Xterms are not available under Windows.

------------------------------------------------------------------------------
1.8  'help'                                                    *csupport-help*
------------------------------------------------------------------------------
Plugin help
-----------
The root menu item 'help (plugin)' shows this plugin help in a help window.
The help tags must have been generated with
  :helptags ~/.vim/doc
The hotkey is \hp (for "help plugin").

Displaying a manual
-------------------
The root menu item 'show manual' shows the manual for the word under the
cursor. If there is more than one manual a selection list will be presented.
If there is no word under the cursor you can type in a name.  An interface to
the on-line reference manuals must be installed (usually man(1) for
Linux/Unix, see|csupport-custom-glob-vars|).
The hotkey is \hm (for "help manual").

==============================================================================
2.  USAGE WITHOUT GUI  (Vim)                              *csupport-usage-vim*
==============================================================================

The frequently used constructs can be inserted with key mappings.  The
mappings are also described in the document c-hot-keys.pdf (reference card,
part of this package).
Hint: Typing speed matters. The combination of a leader ('\') and the
following character(s) will only be recognized for a short time.
The insert mode mappings start with ` (backtick).

Legend:  (i) insert mode, (n) normal mode, (v) visual mode

  -- Help ---------------------------------------------------------------

  \hm       show manual for word under the cursor (n,i)
  \hp       show plugin help                      (n,i)

  -- Comments -----------------------------------------------------------

  \cl       end-of-line comment                 (n,v,i)
  \cj       adjust end-of-line comment(s)       (n,v,i)
  \cs       set end-of-line comment column      (n)
  \c*       code -> comment /* */               (n,v)
  \cc       code -> comment //                  (n,v)
  \co       comment -> code                     (n,v)
  \cfr      frame comment                       (n,i)
  \cfu      function comment                    (n,i)
  \cme      method description                  (n,i)
  \ccl      class description                   (n,i)
  \cfdi     file description (implementation)   (n,i)
  \cfdh     file description (header)           (n,i)
  \ccs      C/C++-file section  (tab. compl.)   (n,i)
  \chs      H-file section      (tab. compl.)   (n,i)
  \ckc      keyword comment     (tab. compl.)   (n,i)
  \csc      special comment     (tab. compl.)   (n,i)
  \cd       date                                (n,v,i)
  \ct       date \& time                        (n,v,i)

  -- Statements ---------------------------------------------------------

  \sd       do { } while                        (n,v,i)
  \sf       for                                 (n,i)
  \sfo      for { }                             (n,v,i)
  \si       if                                  (n,i)
  \sif      if { }                              (n,v,i)
  \sie      if else                             (n,v,i)
  \sife     if { } else { }                     (n,v,i)
  \se       else { }                            (n,v,i)
  \sw       while                               (n,i)
  \swh      while { }                           (n,v,i)
  \ss       switch                              (n,v,i)
  \sc       case                                (n,i)
  \s{ \sb   { }                                 (n,v,i)

  -- Preprocessor -------------------------------------------------------

  \ps       choose a standard library include   (n,i)
  \pc       choose a C99 include                (n,i)
  \p<       #include <>                         (n,i)
  \p"       #include ""                         (n,i)
  \pd       #define                             (n,i)
  \pu       #undef                              (n,i)
  \pie      #if  #else #endif                   (n,v,i)
  \pid      #ifdef #else #endif                 (n,v,i)
  \pin      #ifndef #else #endif                (n,v,i)
  \pind     #ifndef #def #endif                 (n,v,i)
  \pi0      #if 0 #endif                        (n,v,i)
  \pr0      remove #if 0 #endif                 (n,i)
  \pe       #error                              (n,i)
  \pl       #line                               (n,i)
  \pp       #pragma                             (n,i)

  -- Idioms -------------------------------------------------------------

  \if       function                            (n,v,i)
  \isf      static function                     (n,v,i)
  \im       main()                              (n,v,i)
  \i0       for( x=0; x<n; x+=1 )               (n,v,i)
  \in       for( x=n-1; x>=0; x-=1 )            (n,v,i)
  \ie       enum   + typedef                    (n,i)
  \is       struct + typedef                    (n,i)
  \iu       union  + typedef                    (n,i)
  \ip       printf()                            (n,i)
  \isc      scanf()                             (n,i)
  \ica      p=calloc()                          (n,i)
  \ima      p=malloc()                          (n,i)
  \isi      sizeof()                            (n,v,i)
  \ias      assert()                            (n,v)
  \ii       open input file                     (n,i)
  \io       open output file                    (n,i)

  -- Snippets -----------------------------------------------------------

  \nr       read code snippet                   (n,i)
  \nw       write code snippet                  (n,v,i)
  \ne       edit code snippet                   (n,i)
  \np       pick up prototype                   (n,v,i)
  \ni       insert prototype(s)                 (n,i)
  \nc       clear  prototype(s)                 (n,i)
  \ns       show   prototype(s)                 (n,i)
  \ntl      edit local templates                (n,i)
  \ntg      edit global templates               (n,i)
  \ntr      rebuild templates                   (n,i)

  -- C++ ----------------------------------------------------------------

  \+co      cout  <<  << endl;                  (n,i)
  \+"       << ""                               (n,i)
  \+c       class                               (n,i)
  \+ps      #include <...> STL                  (n,i)
  \+pc      #include <c..> C                    (n,i)
  \+cn      class (using new)                   (n,i)
  \+ci      class implementation                (n,i)
  \+cni     class (using new) implementation    (n,i)
  \+mi      method implementation               (n,i)
  \+ai      accessor implementation             (n,i)

  \+tc      template class                      (n,i)
  \+tcn     template class (using new)          (n,i)
  \+tci     template class implementation       (n,i)
  \+tcni    template class (using new) impl.    (n,i)
  \+tmi     template method implementation      (n,i)
  \+tai     template accessor implementation    (n,i)

  \+tf      template function                   (n,i)
  \+ec      error class                         (n,i)
  \+tr      try ... catch                       (n,v,i)
  \+ca      catch                               (n,v,i)
  \+c.      catch(...)                          (n,v,i)

  -- Run ----------------------------------------------------------------

  \rc       save and compile                    (n,i)
  \rl       link                                (n,i)
  \rr       run                                 (n,i)
  \ra       set comand line arguments           (n,i)
  \rm       run make                            (n,i)
  \rmc      run 'make clean'                    (n,i)
  \rme      executable to run                   (n,i)
  \rma      cmd. line arg. for make             (n,i)
  \rp       run splint                          (n,i)
  \rpa      cmd. line arg. for splint           (n,i)
  \rk       run CodeCheck (TM)                  (n,i)
  \rka      cmd. line arg. for CodeCheck (TM)   (n,i)
  \rd       run indent                          (n,v,i)
  \rh       hardcopy buffer                     (n,v,i)
  \rs       show plugin settings                (n,i)
  \rx       set xterm size                      (n, only Linux/UNIX & GUI)
  \ro       change output destination           (n,i)

  -- Load / Unload C/C++ Support ----------------------------------------

  \lcs      Load C/C++ Support Menus            (n, GUI only)
  \ucs      Unload C/C++ Support Menus          (n, GUI only)

The hotkeys are defined in the file type plugin c.vim (part of this csupport
plugin package) and described in the document c-hot-keys.pdf

Changing the default map leader '\'
-----------------------------------
The map leader can be changed by the user by setting a global variable in the
file .vimrc 

 let g:C_MapLeader  = ','

The map leader is now a comma. The 'line end comment' command is now defined
as ',cl'. This setting will be used as a so called local leader and influences
only files with filetype 'c' and 'cpp'.

==============================================================================
3.  HOTKEYS                                                 *csupport-hotkeys*
==============================================================================

The following hotkeys are defined in normal, visual and insert mode:

       F9   compile and link
   Alt-F9   write buffer and compile
  Ctrl-F9   run executable
 Shift-F9   set command line arguments

 Shift-F2   switch between source files and header files

The hotkeys are defined in the file type plugin  c.vim.  All hotkeys from the
non-GUI mode also work for gVim (see |csupport-usage-vim|).

Shift-F2 can be used to switch between source files and header files if the
plugin a.vim (http://vim.sourceforge.net/scripts/script.php?script_id=31) is
present.  To suppress the creation of a new header file when switching from a
source file the file ~/.vimrc should contain a line

  let g:alternateNoDefaultAlternate = 1

A header file will only be opened if it already exists.

The Shift-key is dead when you are working with Vim in a console terminal
(non-Gui). You could add 

  noremap   \a        :A<CR>
 inoremap   \a   <C-C>:A<CR>

to get a hot key for this case.

==============================================================================
4.  CUSTOMIZATION                                            *csupport-custom*
==============================================================================

------------------------------------------------------------------------------
4.1  GLOBAL VARIABLES                              *csupport-custom-glob-vars*
------------------------------------------------------------------------------

Several global variables are checked by the script to customize it:

  ----------------------------------------------------------------------------
  GLOBAL VARIABLE           DEFAULT VALUE                    TAG (see below)
  ----------------------------------------------------------------------------
  g:C_GlobalTemplateFile     plugin_dir.'c-support/templates/Templates'
  g:C_LocalTemplateFile      $HOME.'/.vim/c-support/templates/Templates'
  g:C_TemplateOverwrittenMsg 'yes'
  g:C_Ctrl_j                 'on'

  g:C_CodeSnippets           plugin_dir.'/c-support/codesnippets/'
  g:C_Dictionary_File        ''
  g:C_LoadMenus              'yes'
  g:C_MenuHeader             'yes'
  g:C_OutputGvim             'vim'
  g:C_Root                   '&C\/C\+\+.'
  g:C_XtermDefaults          '-fa courier -fs 12 -geometry 80x24'
  g:C_Printheader            "%<%f%h%m%<  %=%{strftime('%x %X')}     Page %N"
  g:C_MapLeader              '\'
  g:C_GuiSnippetBrowser      'gui'
  g:C_GuiTemplateBrowser     'gui'

  Linux/UNIX:
   g:C_ObjExtension          '.o'
   g:C_ExeExtension          ''
   g:C_CCompiler             'gcc'
   g:C_CplusCompiler         'g++'
   g:C_Man                   'man'
  Windows:
   g:C_ObjExtension          '.obj'
   g:C_ExeExtension          '.exe'
   g:C_CCompiler             'gcc.exe'
   g:C_CplusCompiler         'g++.exe'
   g:C_Man                   'man.exe'
  g:C_VimCompilerName        gcc
  g:C_CFlags                 '-Wall -g -O0 -c'
  g:C_LFlags                 '-Wall -g -O0'
  g:C_Libs                   '-lm'
  g:C_LineEndCommColDefault  49
  g:C_CExtension             'c'
  g:C_TypeOfH                'cpp'
  g:C_SourceCodeExtensions   'c cc cp cxx cpp CPP c++ C i ii'

  g:C_CodeCheckExeName       'check'
  g:C_CodeCheckOptions       '-K13'

The variable plugin_dir will automatically be set to one of the following values:
  $HOME.'/.vim/'        for Linux/Unix
  $VIM.'/vimfiles/'     for Windows

  ----------------------------------------------------------------------------

 1. group: g:C_GlobalTemplateFile : Sets the master template file (see|csupport-templates|)
           g:C_LocalTemplateFile  : Sets the local template file  (see|csupport-templates|)
           g:C_TemplateOverwrittenMsg : message if template is overwritten
           g:C_Ctrl_j                 : hotkey Ctrl-j  'on'/'off' (see|csupport-Ctrl-j|)

 2. group: g:C_CodeSnippets       : The name of the code snippet directory
                                   (see |csupport-snippets|).
           g:C_Dictionary_File    : The name(s) of the dictionary file(s) used for
                                    word completion (see also |csupport-dictionary|)
           g:C_LoadMenus          : Load menus and mappings ("yes", "no") at startup.
           g:C_MenuHeader         : Switch the submenu header on/off.
           g:C_OutputGvim         : when program is running output goes to the vim
                                    command line ("vim"), to a buffer ("buffer") or to
                                    an xterm ("xterm").
           g:C_Root               : The name of the root menu entry of this plugin
                                           (see |csupport-custom-root|).
           g:C_XtermDefaults      : the xterm defaults
           g:C_Printheader        : hardcopy: definition of the page header
           g:C_MapLeader          : the map leader for hotkeys (see|csupport-usage-vim|)
           g:C_GuiSnippetBrowser  : code snippet browser: 'gui', 'commandline'
           g:C_GuiTemplateBrowser : code template browser: 'gui', 'explorer', 'commandline' 
 
 3. group: g:C_CExtension             : Extension of C files. Everything else is C++.
           g:C_TypeOfH                : filetype of header files with extension 'h' (c,cpp)
           g:C_SourceCodeExtensions   : filename extensions for C/C++
                                        implementation files
           g:C_CCompiler              : The name of the C compiler.
           g:C_CplusCompiler          : The name of the C++ compiler.
           g:C_VimCompilerName        : the compiler name used by :compiler
           g:C_Man                    : The name of the man utility.
           g:C_CFlags                 : Compiler flags used for a compilation.
           g:C_LFlags                 : Compiler flags used for linkage.
           g:C_Libs                   : Libraries to link with.
           g:C_ObjExtension           : C/C+ file extension for objects
                                        (leading point required if not empty)
           g:C_ExeExtension           : C/C+ file extension for executables
                                        (leading point required if not empty)
           g:C_LineEndCommColDefault  : Default starting column for end-of-line comments.
           g:C_CodeCheckExeName       : The name of the CodeCheck (TM) executable
                                        (the default is 'check')
           g:C_CodeCheckOptions       : Default options for CodeCheck (TM)
                                       (see |csupport-run-codecheck|).

To override the default add appropriate assignments to ~/.vimrc .

------------------------------------------------------------------------------
4.2  THE ROOT MENU                                      *csupport-custom-root*
------------------------------------------------------------------------------

The variable g:C_Root, if set (in '.vimrc' or in '.gvimrc'), gives the name
of the single gVim root menu entry in which the C/C++ submenus will be put.
The default is

  '&C\/C\+\+.'
                  ''
Note the terminating dot. 

If you want to set the plugin root menu into another menu, e.g. 'Plugin',
this is done by the following line in '.vimrc'

  let g:C_Root = '&Plugin.&C\/C\+\+.'

------------------------------------------------------------------------------
4.3  SYSTEM-WIDE INSTALLATION                           *csupport-system-wide*
------------------------------------------------------------------------------

A system-wide installation (one installation for all users) is done as
follows.

As *** SUPERUSER *** :

(1) Find the Vim installation directory.
The Vim Ex command ':echo $VIM' gives '/usr/local/share/vim' or something like
that. Beyond this directory you will find the Vim installation,  e.g. in
'/usr/local/share/vim/vim73' if Vim version 7.3 has been installed
(Windows: 'C:\Program Files\Vim').

(2) Create a new subdirectory 'vimfiles', e.g. '/usr/local/share/vim/vimfiles'
(Windows: 'C:\Program Files\Vim\vimfiles').

(3) Install C/C++ Support
Copy the archive cvim.zip to this new directory and unpack it:
  unzip cvim.zip

(4) Generate the help tags:
  :helptags $VIM/vimfiles/doc

SPECIAL CASES. Some Linux distributions use non-standard names for Vim
directories. SUSE has a directory '/usr/share/vim/site' to put plugins in.
These directories will not be found automatically.  After installing the
plugin below '/usr/share/vim/site' the use of the templates will be enabled by
the following line in '~/.vimrc':

  let g:C_GlobalTemplateFile = '/usr/share/vim/site/c-support/templates/Templates'

As *** USER *** :

Create your private snippet directory:

  mkdir --parents  ~/.vim/c-support/codesnippets

You may want to copy the snippets coming with this plugin (in
$VIM/vimfiles/c-support/codesnippets) into the new directory or to set a
link to the global directory.

Create your private template directory:

  mkdir --parents  ~/.vim/c-support/templates

Create a private template file 'Templates' (compulsory) in this directory to
overwrite some macros, e.g.

 *|AUTHOR|*    = your name
 *|AUTHORREF|* = ...
 *|EMAIL|*     = ...
 *|COMPANY|*   = ...
 *|COPYRIGHT|* = ...

You can also have local templates which overwrite the global ones. To suppress
the messages in this case set a global variable in '~/.vimrc' (Windows:
'~\_vimrc') :

  let g:C_TemplateOverwrittenMsg= 'no'

The default is 'yes'.

==============================================================================
5.  TEMPLATE FILES AND TAGS                               *csupport-templates*
==============================================================================

------------------------------------------------------------------------------
5.1  TEMPLATE FILES                                 *csupport-templates-files*
------------------------------------------------------------------------------

Nearly all menu entries insert code snippets or comments. All of these are
contained within template files and can be changed by the user to meet their
requirements.

The master template file is '$HOME/.vim/c-support/templates/Templates' for a
user installation and  '$VIM/vimfiles/c-support/templates/Templates' for a
system-wide installation (see|csupport-system-wide|).

The master template file starts with a macro section followed by templates for
single menu items or better by including other template files grouping the
templates according to the menu structure of this plugin. The master file
could look like this:

  $
  $ =============================================================
  $ ========== USER MACROS ======================================
  $ =============================================================
  $
 *|AUTHOR|*    = Dr. Fritz Mehner
 *|AUTHORREF|* = mn
 *|EMAIL|*     = mehner@fh-swf.de
 *|COMPANY|*   = FH Südwestfalen, Iserlohn
 *|COPYRIGHT|* = Copyright (c)*|YEAR|,|AUTHOR|*
  $
  $ =============================================================
  $ ========== FILE INCLUDES ====================================
  $ =============================================================
  $
 *|includefile|* = c.comments.template
 *|includefile|* = c.cpp.template
 *|includefile|* = c.idioms.template
 *|includefile|* = c.preprocessor.template
 *|includefile|* = c.statements.template

Lines starting with a dollar sign are comments. The section starting
with *|AUTHOR|* assigns values to predefined tags
(see|csupport-templates-macros|) to personalize some templates. Other
predefined tags with given default values can be used (e.g. *|YEAR|* ).

User defined tags are possible. They have the following syntax:

 *|macroname|* = replacement

A macroname starts with a letter (uppercase or lowercase) followed by zero or
more letters, digits or underscores.

------------------------------------------------------------------------------
5.2  MACROS                                        *csupport-templates-macros*
------------------------------------------------------------------------------

The following macro names are predefined. The first group is used to
personalize templates.

 ----------------------------------------------------------------------------
 PREDEFINED MACROS  DEFAULT VALUE
 ----------------------------------------------------------------------------
*|AUTHOR|*          ""
*|AUTHORREF|*       ""
*|EMAIL|*           ""
*|COMPANY|*         ""
*|PROJECT|*         ""
*|COPYRIGHTHOLDER|* ""
*|STYLE|*           ""
*|includefile|*     ""

*|BASENAME|*        filename without path and suffix
*|DATE|*            the preferred date representation for the current locale
                    without the time
*|FILENAME|*        filename without path
*|PATH|*            path without filename
*|SUFFIX|*          filename suffix
*|TIME|*            the preferred time representation for the current locale
                    without the date and the time zone or name or abbreviation
*|YEAR|*            the year as a decimal number including the century

The macro *|includefile|* can  be used to include an additional template file.
A file will be included only once. Commenting and uncommenting include macros
is a simple way to switch between several sets of templates (see also
|csupport-run-templates|). Overwriting existing macros and templates is
possible.

 ----------------------------------------------------------------------------
 PREDEFINED TAGS
 ----------------------------------------------------------------------------
 <CURSOR>,{CURSOR}    The cursor position after insertion of a template
 <+text+>,<-text->,   Jump targets in templates. Jump with Ctrl-j.
 {+text+},{-text-}    See |csupport-templates-jump|.

 <SPLIT>              The split point when inserting in visual mode
                      (see|csupport-templates-definition|)

A dependent template file can start with its own macro section. There is no
need to have all user defined macros in the master file.
When the first template definition is found (see below) macro definitions are
no longer recognized.
Use the tag variant with curly braces if the indentation of the following line
is wrong after template insertion.

------------------------------------------------------------------------------
5.2.1  USER DEFINED FORMATS FOR DATE AND TIME        *csupport-templates-date*
------------------------------------------------------------------------------
The format for *|DATE|* ,*|TIME|* , and*|YEAR|* can be set by the user. The
defaults are
    *|DATE|*        '%x'
    *|TIME|*        '%X'
    *|YEAR|*        '%Y'
See the manual page of the C function strftime() for the format.  The accepted
format depends on your system, thus this is not portable!  The maximum length
of the result is 80 characters.

User defined formats can be set using the following global variables in
~/.vimrc ,  e.g.
    let g:C_FormatDate            = '%D'
    let g:C_FormatTime            = '%H:%M'
    let g:C_FormatYear            = 'year %Y'

------------------------------------------------------------------------------
5.3  TEMPLATES                                      *csupport-templates-names*
------------------------------------------------------------------------------

5.3.1  Template names

The template behind a menu entry is identified by a given name. The first part
of the name identifies the menu, the second part identifies the item. The
modes are also hard coded (see|csupport-templates-definition|for the use of
<SPLIT>).

  TEMPLATE NAME                                              MODES
 --------------------------------------------------------------------------

  comment.class                                              normal
  comment.end-of-line-comment                                normal
  comment.file-description                                   normal
  comment.file-description-header                            normal
  comment.file-section-cpp-class-defs                        normal
  comment.file-section-cpp-class-implementations-exported    normal
  comment.file-section-cpp-class-implementations-local       normal
  comment.file-section-cpp-data-types                        normal
  comment.file-section-cpp-function-defs-exported            normal
  comment.file-section-cpp-function-defs-local               normal
  comment.file-section-cpp-header-includes                   normal
  comment.file-section-cpp-local-variables                   normal
  comment.file-section-cpp-macros                            normal
  comment.file-section-cpp-prototypes                        normal
  comment.file-section-cpp-typedefs                          normal
  comment.file-section-hpp-exported-class-defs               normal
  comment.file-section-hpp-exported-data-types               normal
  comment.file-section-hpp-exported-function-declarations    normal
  comment.file-section-hpp-exported-typedefs                 normal
  comment.file-section-hpp-exported-variables                normal
  comment.file-section-hpp-header-includes                   normal
  comment.file-section-hpp-macros                            normal
  comment.frame                                              normal
  comment.function                                           normal
  comment.keyword-bug                                        normal
  comment.keyword-compiler                                   normal
  comment.keyword-keyword                                    normal
  comment.keyword-todo                                       normal
  comment.keyword-tricky                                     normal
  comment.keyword-warning                                    normal
  comment.keyword-workaround                                 normal
  comment.method                                             normal
  comment.special-constant-type-is-long                      normal
  comment.special-constant-type-is-unsigned-long             normal
  comment.special-constant-type-is-unsigned                  normal
  comment.special-empty                                      normal
  comment.special-fall-through                               normal
  comment.special-implicit-type-conversion                   normal
  comment.special-no-return                                  normal
  comment.special-not-reached                                normal
  comment.special-remains-to-be-implemented                  normal

  cpp.accessor-implementation                                normal
  cpp.catch                                                  normal, visual
  cpp.catch-points                                           normal, visual
  cpp.cin                                                    normal
  cpp.class-definition                                       normal
  cpp.class-implementation                                   normal
  cpp.class-using-new-definition                             normal
  cpp.class-using-new-implementation                         normal
  cpp.cout-operator                                          normal
  cpp.cout                                                   normal
  cpp.error-class                                            normal
  cpp.extern                                                 normal, visual
  cpp.method-implementation                                  normal
  cpp.namespace-block                                        normal, visual
  cpp.namespace                                              normal
  cpp.namespace-std                                          normal
  cpp.open-input-file                                        normal
  cpp.open-output-file                                       normal
  cpp.operator-in                                            normal
  cpp.operator-out                                           normal
  cpp.output-manipulator-boolalpha                           normal
  cpp.output-manipulator-dec                                 normal
  cpp.output-manipulator-endl                                normal
  cpp.output-manipulator-fixed                               normal
  cpp.output-manipulator-flush                               normal
  cpp.output-manipulator-hex                                 normal
  cpp.output-manipulator-internal                            normal
  cpp.output-manipulator-left                                normal
  cpp.output-manipulator-oct                                 normal
  cpp.output-manipulator-right                               normal
  cpp.output-manipulator-scientific                          normal
  cpp.output-manipulator-setbase                             normal
  cpp.output-manipulator-setfill                             normal
  cpp.output-manipulator-setiosflag                          normal
  cpp.output-manipulator-setprecision                        normal
  cpp.output-manipulator-setw                                normal
  cpp.output-manipulator-showbase                            normal
  cpp.output-manipulator-showpoint                           normal
  cpp.output-manipulator-showpos                             normal
  cpp.output-manipulator-uppercase                           normal
  cpp.rtti-const-cast                                        normal
  cpp.rtti-dynamic-cast                                      normal
  cpp.rtti-reinterpret-cast                                  normal
  cpp.rtti-static-cast                                       normal
  cpp.rtti-typeid                                            normal
  cpp.template-accessor-implementation                       normal
  cpp.template-class-definition                              normal
  cpp.template-class-implementation                          normal
  cpp.template-class-using-new-definition                    normal
  cpp.template-class-using-new-implementation                normal
  cpp.template-function                                      normal
  cpp.template-method-implementation                         normal
  cpp.try-catch                                              normal, visual

  idioms.assert                                              normal
  idioms.calloc                                              normal
  idioms.enum                                                normal, visual
  idioms.fprintf                                             normal
  idioms.fscanf                                              normal
  idioms.function                                            normal, visual
  idioms.function-static                                     normal, visual
  idioms.main                                                normal, visual
  idioms.malloc                                              normal
  idioms.open-input-file                                     normal
  idioms.open-output-file                                    normal
  idioms.printf                                              normal
  idioms.scanf                                               normal
  idioms.sizeof                                              normal
  idioms.struct                                              normal, visual
  idioms.union                                               normal, visual

  preprocessor.define                                        normal
  preprocessor.ifdef-else-endif                              normal, visual
  preprocessor.if-else-endif                                 normal, visual
  preprocessor.ifndef-def-endif                              normal, visual
  preprocessor.ifndef-else-endif                             normal, visual
  preprocessor.include-global                                normal
  preprocessor.include-local                                 normal
  preprocessor.undefine                                      normal

  statements.block                                           normal, visual
  statements.case                                            normal
  statements.do-while                                        normal, visual
  statements.for-block                                       normal
  statements.for                                             normal
  statements.if-block-else                                   normal, visual
  statements.if-block                                        normal, visual
  statements.if-else                                         normal, visual
  statements.if                                              normal
  statements.switch                                          normal, visual
  statements.while-block                                     normal, visual
  statements.while                                           normal


5.3.2  Template definition                     *csupport-templates-definition*

A template definition starts with a template head line with the following
syntax:

  == templatename == [ position == ]

The templatename is one of the above template identifiers. The position
attribute is optional. Possible attribute values are:

  above     insert the template before the current line
  append    append the template to the current line
  below     insert the template below the current line
  insert    insert the template at the cursor position
  start     insert the template before the first line of the buffer

An example:

  == comment.function ==
  /*
   * ===  FUNCTION  =======================================================
   *         Name:  <CURSOR>
   *  Description:
   * ======================================================================
   */

The definition of a template ends at the next head line or at the end of the
file.

Templates for the visual mode can use <SPLIT>. The text before <SPLIT> will
than be inserted above the marked area, the text after <SPLIT> will be
inserted behind the marked area. An example:

  == statements.if-block-else ==
  if ( <CURSOR> ) {
  <SPLIT>} else {
  }

If applied to the marked block

  xxxxxxxxxxx
  xxxxxxxxxxx

this template yields

  if (  ) {
    xxxxxxxxxxx
    xxxxxxxxxxx
  } else {
  }

The templates with a visual mode are shown in the table under
|csupport-templates-names|.

5.3.3  Template expansion                       *csupport-templates-expansion*

There are additional ways to control the expansion of a template.

USER INPUT
----------
If the usage of a yet undefined user macro starts with a question mark the
user will be asked for the replacement first, e.g. with the following template

  == idioms.function ==
  void<CURSOR>
 *|?FUNCTION_NAME|* (  )
  {
  <SPLIT> return ;
  }   /* -----  end of function*|FUNCTION_NAME|* ----- */

The user can specify the function name which then will be applied twice. If
the macro was already in use the old value will be suggested as default.

MACRO MANIPULATION
------------------

A macro expansion can be controlled by the following attributes

  :l    change macro text to lowercase
  :u    change macro text to uppercase
  :c    capitalize macro text
  :L    legalize name

The include guard template is an example for the use of ':L' :

  == preprocessor.ifndef-def-endif ==
 #ifndef *|?BASENAME:L|_INC*
 #define *|BASENAME|_INC*
 <CURSOR><SPLIT>
 #endif   // ----- #ifndef*|BASENAME|_INC* -----

The base name of the file shall be used as part of the include guard name.
The predefined macro*|BASENAME|* is used to ask for this part because this
macro has already a defined value. That value can accepted or replaced by the
user. For the filename 'test test++test.h' the legalized base name
'TEST_TEST_TEST' will be suggested.

Legalization means:
 - replace all whitespaces by underscores
 - replace all non-word characters by underscores
 - replace '+' and '-' by underscore

5.3.4  The macros <+text+> etc.                      *csupport-templates-jump*

There are four macro types which can be used as jump targets in templates:

 <+text+>   Can be jumped to by hitting Ctrl-j.
 {+text+}   Same as <+text+>. Used in cases where indentation gives unwanted
            results with the first one.
 
 <-text->   Same as the two above. Will be removed if the template is used
 {-text-}   in visual mode.

The text inside the brackets is userdefined and can be empty. The text
can be composed from letters (uppercase and lowercase), digits, underscores
and blanks. After the insertion of an template these jump targets will be
highlighted. 

5.3.5  Command Ctrl-j                                        *csupport-Ctrl-j*

Use the command Ctrl-j to jump to the next target. The target will be removed
and the mode will switched to insertion. Ctrl-j works in normal and in insert
mode.

The template for a function can be written as follows:

 == idioms.function ==
 void<CURSOR>
 |?FUNCTION_NAME| ( <+argument list+> )
 {
 <SPLIT>  return <+return value+>;
 }    /* -----  end of function |FUNCTION_NAME|  ----- */

The cursor will be set behind 'void'. You can remove 'void' easily with 
Ctrl-w (delete word before cursor) and insert a new type. A Ctrl-j leads you
to the argument list. The target disappears and you can type on. When the
function body is written a final Ctrl-j brings you to the return statement.

The following example shows the usage of the type {-text-}. The idiom for the
opening of a file marks the line before the file is closed. This is also the
line where the template will be split to surround a marked area. In this case
(visual mode) the target is not needed and therefore removed (minus signs as
mnemonic). In normal and insert mode the target is meaningful and will be
therefore be present.  The form <-...-> would result in a wrong indentation of
the file close statement. The brace type will be handled as a block and the
indentation will be correct.

 == cpp.open-input-file ==
 char *ifs_file_name = "<CURSOR>";    /* input  file name       */
 ifstream ifs;              /* create ifstream object */
 
 ifs.open (ifs_file_name);    /* open ifstream          */
 if (!ifs) {
  cerr << "\nERROR : failed to open input  file " << ifs_file_name << endl;
  exit (EXIT_FAILURE);
 }
 <SPLIT>{-continue here-}
 ifs.close ();    /* close ifstream         */

Extra feature of Ctrl-j
-----------------------
If none of the above described targets is left Ctrl-j can be used to jump
behind closing brackets, parenthesis, braces,  or string terminators ('"`).
This feature is limited to the current line. Ctrl-j does not jump behind the
last character in a line.


How to switch the mapping for Ctrl-j off
----------------------------------------
The original meaning of Ctrl-j is 'move [n] lines downward' (see |CTRL-j|).
If you are accustomed to use the deafult and don't like these jump targets you
can switch them off.  Put the following line in the file .vimrc :

  let g:C_Ctrl_j   = 'off'

The default value of g:C_Ctrl_j is 'on'. You do not have to change the
template files. All jump targets will be removed before a template will be
inserted. 

==============================================================================
5.4  SWITCHING BETWEEN TEMPLATE SETS                 *csupport-templates-sets*
==============================================================================

This plugin comes with two sets of templates. These are suggestions. You may
want to have additional sets for different projects or occasionally want to
use doxygen style comments.  To facilitate switching use the macro*|STYLE|*
(|csupport-templates-files|) to define a unique name and the
IF-ENDIF-construct to choose a particular set of files for example:

   ...

 *|STYLE|*    = C
  $
  $ =============================================================
  $ ========== FILE INCLUDES ====================================
  $ =============================================================
  $
  == IF *|STYLE|* IS C  ==
  $
  |includefile| = c.comments.template
  |includefile| = c.cpp.template
  |includefile| = c.idioms.template
  |includefile| = c.preprocessor.template
  |includefile| = c.statements.template
  $
  == ENDIF ==

   ...

The syntax is as follows:

  == IF macro_name IS macro_value  ==
   
  == ENDIF ==

Includes outside an IF-ENDIF construct are associated with the default style
'default'. A style set does not have to a complete set of templates. For an
incomplete set the other templates are taken from the default style.

IF, IS, and ENDIF are keywords.

HINT. Use these constructs to avoid overwriting your templates when updating
csupport. Copy and rename the set of files you want to change and surround the
includes with an appropriate IF-construct:

 *|STYLE|*    = MY_C
  $
   ...
  $
  == IF *|STYLE|* IS MY_C  ==
  |includefile| = my_c.comments.template
  |includefile| = my_c.cpp.template
  |includefile| = my_c.idioms.template
  |includefile| = my_c.preprocessor.template
  |includefile| = my_c.statements.template
  == ENDIF ==

Keep a copy of the main template file 'Templates' because this file will be
overwritten if you do not update manually.

==============================================================================
5.5  BINDING A STYLE TO A FILE EXTENSION             *csupport-templates-bind*
==============================================================================

You can bind the existing styles to one or more filename extensions. To do so
assign a Dictionary to the global variable g:C_Styles in '~/.vimrc' :

let g:C_Styles = { '*.c,*.h' : 'default', '*.cc,*.cpp,*.hh' : 'CPP' }

A Dictionary is created with a comma separated list of entries in curly
braces.  Each entry has a key and a value, separated by a colon.  Each key can
only appear once. The keys are themselves a comma separated list of filename
pattern. The values are existing styles defined in the template files.
The given style will be set automatically when switching to a buffer or
opening a new buffer with the associated filename pattern and supersedes the
macro *|STYLE|* .

==============================================================================
6.  C/C++ DICTIONARY                                     *csupport-dictionary*
==============================================================================

The files

 c-c++-keywords.list
 k+r.list
 stl_index.list

are a part of this plugin and can be used (together with your own lists) as
dictionaries for automatic word completion.  This feature is enabled by
default. The default word lists are

  plugin_dir/c-support/wordlists/c-c++-keywords.list
  plugin_dir/c-support/wordlists/k+r.list
  plugin_dir/c-support/wordlists/stl_index.list

The variable plugin_dir will automatically be set by the plugin to one of the
following values:
  $HOME.'/.vim/'        for Linux/Unix
  $VIM.'/vimfiles/'     for Windows
If you want to use an additional list MyC.list put the following lines into
 ~/.vimrc :

  let g:C_Dictionary_File = PLUGIN_DIR.'/c-support/wordlists/c-c++-keywords.list,'.
        \                   PLUGIN_DIR.'/c-support/wordlists/k+r.list,'.
        \                   PLUGIN_DIR.'/c-support/wordlists/stl_index.list,'.
        \                   PLUGIN_DIR.'/c-support/wordlists/MyC.list'

When in file ~/.vimrc the name PLUGIN_DIR has to be replaced by $HOME or
$VIM (see above). Whitespaces in the pathnames have to be escaped with a
backslash.
The right side is a comma separated list of files. Note the point at the end
of the first line (string concatenation) and the backslash in front of the
second line (continuation line).
You can use Vim's dictionary feature CTRL-X, CTRL-K (and CTRL-P, CTRL-N).

==============================================================================
7.  EXTENDING  ctags                                          *csupport-ctags*
==============================================================================

------------------------------------------------------------------------------
7.1  make AND qmake                                      *csupport-ctags-make*
------------------------------------------------------------------------------

The use of the Vim plugin taglist.vim (Author: Yegappan Lakshmanan) is highly
recommended. It uses the program ctags which generates tag files for 3 dozen
languages (Exuberant Ctags, Darren Hiebert, http://ctags.sourceforge.net).
With the following extensions the list of targets in a makefile can be shown
in the taglist window.

 1) Append the file customization.ctags to the file $HOME/.ctags .

 2) Add the following lines (from customization.vimrc) to $HOME/.vimrc :

  "
  "-------------------------------------------------------------------
  " taglist.vim : toggle the taglist window
  " taglist.vim : define the title texts for make
  " taglist.vim : define the title texts for qmake
  "-------------------------------------------------------------------
   noremap <silent> <F11>  <Esc><Esc>:Tlist<CR>
  inoremap <silent> <F11>  <Esc><Esc>:Tlist<CR>

  let tlist_make_settings  = 'make;m:makros;t:targets;i:includes'
  let tlist_qmake_settings = 'qmake;t:SystemVariables'

  if has("autocmd")
    " ----------  qmake : set file type for *.pro  ----------
    autocmd BufNewFile,BufRead *.pro  set filetype=qmake
  endif " has("autocmd")

 3) restart vim/gvim

The two maps will toggle the taglist window (hotkey F11) in all editing modes.
The two assignments define the headings for the (q)make sections in the
taglist window.  The autocmd set the file type 'qmake' for the filename
extension 'pro' (ctags needs this).

------------------------------------------------------------------------------
7.2  TEMPLATES                                      *csupport-ctags-templates*
------------------------------------------------------------------------------

If you frequently change the plugin  templates and you are using the taglist
plugin (section above) you may want to use this plugin for navigation. This is
achieved in two steps. First add a new language definition to  the file
$HOME/.ctags :

  --langdef=template
  --langmap=template:.template,TEMPLATE
  --regex-template=/^==\s+([^=]+)\s+==\s*(\s+==\s+([^=]+)\s+==)?/\1/t,template/

Now add the following lines to the file $HOME/.vimrc :

  let tlist_template_settings  = 'template;t:template'
  "---------------------------------------------------------------
  " plugin templates : set filetype for *.template  
  "---------------------------------------------------------------
  if has("autocmd")
    autocmd BufNewFile,BufRead Templates  set filetype=template
    autocmd BufNewFile,BufRead *.template  set filetype=template
  endif " has("autocmd")

The assignment defines the heading for the template section in the taglist
window.  The autocmds set the file type 'template' for the main template file
'Templates' and the includefiles '*.template' (if any).

==============================================================================
8.  FOLDING                                                 *csupport-folding*
==============================================================================

This plugin can be used together with folding.

There are a few peculiarities when the cursor is on a closed fold before
inserting a template:

Normal mode
-----------
Inserting blocks of complete lines below and above a fold (e.g. frame
comments) and inserting at the top of a buffer (e.g. file description) works
as usual.
Insertions which go to the end of a line (e.g. end-of-line comments) and
insertions which go to the cursor position (e.g. 'sizeof()') will be suppressed
and a warning will be shown.

Visual mode
-----------
A range of lines containing closed folds can be surrounded by constructs which
have a visual mode, e.g. a for-loop: 

    for ( ; ; ) {
  +---  4 lines: {------------------------------------------------------------
    }

See |folding| for more information on folding.

==============================================================================
9.  Additional Mappings                                 *csupport-ad-mappings*
==============================================================================

There are a few additional filetype specific key mappings defined in
'~/.vim/ftplugin/c.vim'.

Complete a classical C comment: '/*' => '/* | */' (modes: i,v).

Complete a classical C multi-line comment (mode: i): 
  '/*<CR>' =>  /*
                * |
                */

Open a block (modes: i,v):
  '{<CR>' =>  {
                |
              }
In visual mode the content of the new block will be indented.

==============================================================================
10.  WINDOWS PARTICULARITIES                                *csupport-windows*
==============================================================================

For a user installation the plugin should go into the directory structure below 
  $HOME/vimfiles/
for a system installation below
  $VIM/vimfiles/

The values of the two variables can be found from inside Vim:
   :echo $VIM
or
   :echo $HOME

The configuration files for a user are

  $HOME/_vimrc   and  $HOME/_gvimrc

for the system

  $VIM/_vimrc   and  $VIM/_gvimrc

Compiler settings:

It could be necessary to add further settings for your compiler.  To compile
C++-programs using a Dev-C++ installation (http://www.bloodshed.net) the
following item in $VIM/_vimrc is needed (depends on the Dev-C++ install
directory):

  let g:C_CFlags  = '-Wall -g -o0 -c -I c:\programs\dev-c++\include\g++'

==============================================================================
11.  ADDITIONAL TIPS                                           *csupport-tips*
==============================================================================

(1) gVim. Toggle 'insert mode' <--> 'normal mode' with the right mouse button
    (see mapping in file costumization.gvimrc).

(2) gVim. Use tear off menus.

(3) Try 'Focus under mouse' as window behavior (No mouse click when the mouse
    pointer is back from the menu item).

(4) Use Emulate3Buttons "on" (X11) even for a 3-button mouse. Pressing left
    and right button at the same time without moving your fingers is faster
    then moving a finger to the middle button (often a wheel).

==============================================================================
12.  TROUBLESHOOTING                                *csupport-troubleshooting*
==============================================================================

* I do not see any new main menu item.
  - Was the archive extracted into the right directory?

* How can I see what was loaded?
  - Use ':scriptnames' from the Vim command line.

* No main menu item.
  - Loading of plugin files must be enabled. If not use
      :filetype plugin on
    This is the minimal content of the file '$HOME/.vimrc'. Create one if there
    is none, or better use customization.vimrc.

* Most key mappings do not work.
  - They are defined in a filetype plugin in '$HOME/.vim/ftplugin/'. Use
    ':filetype' to check if filetype plugins are enabled. If not, add the line
      filetype plugin on
    to the file '~/.vimrc'.

* Some hotkeys do not work.
  - The hotkeys might be in use by your graphical desktop environment.  Under
    KDE Ctrl-F9 is the hotkey which let you switch to the 9. desktop.  The key
    settings can usually be redefined.

* Splint and/or CodeCheck menu item not visible.
  - The program is not installed or not found (path not set) or not executable.

==============================================================================
13.  RELEASE NOTES                                    *csupport-release-notes*
==============================================================================
See file c-support/doc/ChangeLog .

==============================================================================
vim:tw=78:noet:ts=2:ft=help:norl:
